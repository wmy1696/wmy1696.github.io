<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Git干货 | 梦永の博客</title><meta name="description" content="RUNOOB Git指令大全 Learn Git Branching  Git配置配置信息Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：  &#x2F;etc&#x2F;gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --"><meta name="keywords" content="Git"><meta name="author" content="梦永"><meta name="copyright" content="梦永"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wmy1696.github.io/posts/44799/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Git干货"><meta property="og:url" content="https://wmy1696.github.io/posts/44799/"><meta property="og:site_name" content="梦永の博客"><meta property="og:description" content="RUNOOB Git指令大全 Learn Git Branching  Git配置配置信息Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：  &#x2F;etc&#x2F;gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wmy1696/cdn/img/git.jpg"><meta property="article:published_time" content="2020-09-14T05:57:48.000Z"><meta property="article:modified_time" content="2020-10-06T12:00:45.937Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="Android Studio快捷键" href="https://wmy1696.github.io/posts/859/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-06 20:00:45'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@master/Hexo/css/flink.min.css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Git配置"><span class="toc-number">1.</span> <span class="toc-text">Git配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置信息"><span class="toc-number">1.1.</span> <span class="toc-text">配置信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看配置信息"><span class="toc-number">1.2.</span> <span class="toc-text">查看配置信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git-工作流程"><span class="toc-number">2.</span> <span class="toc-text">Git 工作流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git-基本操作"><span class="toc-number">3.</span> <span class="toc-text">Git 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建仓库命令"><span class="toc-number">3.1.</span> <span class="toc-text">创建仓库命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交与修改"><span class="toc-number">3.2.</span> <span class="toc-text">提交与修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交日志"><span class="toc-number">3.3.</span> <span class="toc-text">提交日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程操作"><span class="toc-number">3.4.</span> <span class="toc-text">远程操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git-分支管理"><span class="toc-number">4.</span> <span class="toc-text">Git 分支管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#干货"><span class="toc-number">5.</span> <span class="toc-text">干货</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HEAD"><span class="toc-number">5.1.</span> <span class="toc-text">HEAD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相对引用"><span class="toc-number">5.2.</span> <span class="toc-text">相对引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#强制修改分支位置"><span class="toc-number">5.3.</span> <span class="toc-text">强制修改分支位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#撤销变更"><span class="toc-number">5.4.</span> <span class="toc-text">撤销变更</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#整理提交记录"><span class="toc-number">5.5.</span> <span class="toc-text">整理提交记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交互式的-rebase"><span class="toc-number">5.6.</span> <span class="toc-text">交互式的 rebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地栈式提交"><span class="toc-number">5.7.</span> <span class="toc-text">本地栈式提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交技巧"><span class="toc-number">5.8.</span> <span class="toc-text">提交技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Tag"><span class="toc-number">5.9.</span> <span class="toc-text">Git Tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Describe"><span class="toc-number">5.10.</span> <span class="toc-text">Git Describe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#远程仓库"><span class="toc-number">6.</span> <span class="toc-text">远程仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Fetch"><span class="toc-number">6.1.</span> <span class="toc-text">Git Fetch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Pull"><span class="toc-number">6.2.</span> <span class="toc-text">Git Pull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Push"><span class="toc-number">6.3.</span> <span class="toc-text">Git Push</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程服务器拒绝-Remote-Rejected"><span class="toc-number">6.4.</span> <span class="toc-text">远程服务器拒绝!(Remote Rejected)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并特性分支"><span class="toc-number">6.5.</span> <span class="toc-text">合并特性分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#远程跟踪分支"><span class="toc-number">6.6.</span> <span class="toc-text">远程跟踪分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Push-的参数"><span class="toc-number">6.7.</span> <span class="toc-text">Git Push 的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-fetch-的参数"><span class="toc-number">6.8.</span> <span class="toc-text">Git fetch 的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#古怪的-lt-source-gt"><span class="toc-number">6.9.</span> <span class="toc-text">古怪的 &lt;source&gt;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#未完待续"><span class="toc-number">7.</span> <span class="toc-text">未完待续</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/wmy1696/cdn/img/git.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">梦永の博客</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Git干货</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-14 13:57:48"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-09-14</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-10-06 20:00:45"><i class="fas fa-history fa-fw"></i> 更新于 2020-10-06</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Git/">Git</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/posts/44799/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/posts/44799/" itemprop="commentCount"></span></a></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">RUNOOB</a></p>
<p><a href="http://git-scm.com/docs" target="_blank" rel="noopener">Git指令大全</a></p>
<p><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git Branching</a></p>
</blockquote>
<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p>
<p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p>
<ul>
<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li>
<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li>
<li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。<strong>每一个级别的配置都会覆盖上层的相同配置</strong>，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>
</ul>
<p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:/Documents and Settings/$USER。</p>
<p>此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>要检查已有的配置信息，可以使用 git config –list 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure>

<p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br></pre></td></tr></table></figure>

<h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p>一般工作流程如下：</p>
<ol>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ol>
<h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><h2 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init &#x2F;&#x2F;初始化仓库</span><br><span class="line">git clone ssh地址 &#x2F;&#x2F;拷贝远程仓库</span><br></pre></td></tr></table></figure>

<h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .  &#x2F;&#x2F;添加文件到暂存区</span><br><span class="line">git status [-s]&#x2F;&#x2F;查看在你上次提交之后是否有对文件进行再次修改,-s输出短结果</span><br><span class="line">git diff [file] &#x2F;&#x2F;比较文件的不同，即暂存区和工作区的差异。</span><br><span class="line">git commit -m [message]</span><br><span class="line">git commit -a &#x2F;&#x2F;不经过暂存区</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^            # 回退所有内容到上一个版本  </span><br><span class="line">$ git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  </span><br><span class="line">$ git  reset  052e           # 回退到指定版本</span><br><span class="line">#相当于把add进暂存区的文件退回了，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;  #删除暂存区和工作区文件</span><br><span class="line">git rm -f runoob.txt &#x2F;&#x2F;删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。</span><br><span class="line">git rm --cached &lt;file&gt;  &#x2F;&#x2F;想把文件从暂存区域移除，但仍然希望保留在当前工作目录中</span><br><span class="line">git mv [file] [newfile] &#x2F;&#x2F;移动或重命名一个文件、目录或软连接。</span><br></pre></td></tr></table></figure>

<h2 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log &#x2F;&#x2F; 查看历史提交记录。</span><br><span class="line">git log --oneline  &#x2F;&#x2F;历史记录简洁版本</span><br><span class="line">git log --reverse  &#x2F;&#x2F;逆向</span><br><span class="line">git blame &lt;file&gt;   &#x2F;&#x2F;以列表形式查看指定文件的历史修改记录。</span><br></pre></td></tr></table></figure>

<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  &#x2F;&#x2F;显示所有远程仓库</span><br><span class="line">git remote add [shortname] [url]  &#x2F;&#x2F;添加远程仓库</span><br><span class="line">git remote rm name  # 删除远程仓库</span><br><span class="line">git remote rename old_name new_name  # 修改仓库名</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master &#x2F;&#x2F;将远程版本库修改同步到本地</span><br><span class="line">#同步下来的代码不会合并到任何分支，存放在origin&#x2F;master分支上</span><br><span class="line">git diff origin&#x2F;master  &#x2F;&#x2F;查看修改内容</span><br><span class="line">git merge origin&#x2F;master</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; </span><br><span class="line">&#x2F;&#x2F;git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。：</span><br><span class="line">git pull origin master:brantest  </span><br><span class="line">&#x2F;&#x2F;将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;&#x2F;&#x2F;从将本地的分支版本上传到远程并合并</span><br><span class="line">&#x2F;&#x2F;如果本地分支名与远程分支名相同，则可以省略冒号</span><br><span class="line">git push --force origin master</span><br><span class="line">&#x2F;&#x2F;如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数</span><br></pre></td></tr></table></figure>

<h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git branch &#x2F;&#x2F;列出分支</span><br><span class="line">git branch (branchname) &#x2F;&#x2F;创建分支</span><br><span class="line">git checkout (branchname) &#x2F;&#x2F;切换分支</span><br><span class="line">git checkout -b (branchname) &#x2F;&#x2F;创建新分支并立即切换到该分支下</span><br><span class="line">git branch -d (branchname)  &#x2F;&#x2F;删除分支</span><br><span class="line">git merge otherbranch &#x2F;&#x2F;将任何分支合并到当前分支</span><br><span class="line">git diff &#x2F;&#x2F;查看合并冲突，手动改</span><br><span class="line">&#x2F;&#x2F;合并冲突进入一个(master|MERGING)状态，在此打开冲突文件，会显示冲突的部分，修改后add commit,master分支融合成功内容改变，注意此时otherbranch的内容是不变的</span><br><span class="line">&#x2F;&#x2F;合并的分支产生了一个新的提交节点</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase master&#x2F;&#x2F;合并分支, bugFix提交记录，“复制”它们，然后在master逐个的放下去。</span><br><span class="line">git rebase master bugFix</span><br></pre></td></tr></table></figure>

<p>Rebase 的优势就是可以创造更线性的提交历史,<strong>需要跟新master</strong></p>
<h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h1><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是<strong>指向你正在其基础上进行工作的提交记录</strong>。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p>
<p>HEAD -&gt; master -&gt; C1   HEAD 指向 master， master 指向 C1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout C1  &#x2F;&#x2F;HEAD -&gt; C1,通过哈希值指定提交记录</span><br></pre></td></tr></table></figure>

<h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，用 <code>git log</code> 来查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够<strong>唯一标识提交记录的前几个字符</strong>即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>
<p>通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>
<p>相对引用两个简单的用法：</p>
<ol>
<li><p>使用 <code>^</code> 向上移动 1 个提交记录</p>
</li>
<li><p>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></p>
</li>
</ol>
<p>操作符 (^)：把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix^</span><br></pre></td></tr></table></figure>

<h2 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h2><p>使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -f master HEAD~3 &#x2F;&#x2F;将 master 分支强制指向 HEAD 的第 3 级父提交</span><br><span class="line">git branch -f master C6 &#x2F;&#x2F;将master强制指向C6</span><br></pre></td></tr></table></figure>

<h2 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h2><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^  &#x2F;&#x2F;向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</span><br></pre></td></tr></table></figure>

<p><code>git reset</code> 这种“改写历史”的方法对大家一起使用的远程分支是无效的.为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure>

<p>在我们要撤销的提交记录后面多了一个新提交,这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code>是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>
<h2 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h2><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;提交号&gt;</span><br><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure>

<h2 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h2><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你<strong>不清楚你想要的提交记录的哈希值</strong>呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p>
<p>当 rebase UI界面打开时, 你能做3件事:</p>
<ol>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。 它允许你把多个提交记录合并成一个。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure>

<p>Git 严格按照你在对话框中指定的方式<strong>进行了复制</strong>。</p>
<h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p>把 <code>bugFix</code> 分支里的工作合并回 <code>master</code> 分支。你可以选择通过 fast-forward 快速合并到 <code>master</code> 分支上，但这样的话 <code>master</code> 分支就会包含一些调试语句了。</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<ol>
<li><code>git rebase -i</code></li>
<li><code>git cherry-pick</code></li>
</ol>
<p>来达到目的。</p>
<h2 id="提交技巧"><a href="#提交技巧" class="headerlink" title="提交技巧"></a>提交技巧</h2><p>技巧一：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，提交了一次。</p>
<p>此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>可以通过下面的方法来克服困难：</p>
<ol>
<li><p>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</p>
</li>
<li><p>然后用 <code>git commit --amend</code> 来进行一些小修改（git commit –amend既可以对上次提交的内容进行修改，也可以修改提交说明）</p>
</li>
<li><p>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</p>
</li>
<li><p>最后我们把 master 移到修改的最前端</p>
</li>
</ol>
<p>技巧二：我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。</p>
<h2 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h2><p>git tag 在某种程度上 (因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 C1</span><br></pre></td></tr></table></figure>

<h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p><code>git describe</code> 的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p>
<p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p><code>git clone</code> 后，在我们的本地仓库多了一个名为 <code>o/master</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p>
<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>
<p><strong>为什么有 <code>o/</code>？</strong></p>
<p>远程分支有一个命名规范 —— 它们的格式是:</p>
<ul>
<li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li>
</ul>
<p>因此，如果你看到一个名为 <code>o/master</code> 的分支，那么这个分支就叫 <code>master</code>，远程仓库的名称就是 <code>o</code>。</p>
<p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，并不是 <code>o</code>。这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了。不过 <code>origin</code> 对于我们的 UI 来说太长了，因此不得不使用简写 <code>o</code> ，但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 <code>origin</code>!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout o&#x2F;master</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>Git 变成了分离 HEAD 状态，当添加新的提交时 <code>o/master</code> 也不会更新。这是因为 <code>o/master</code> 只有在远程仓库中相应的分支更新了以后才会更新。</p>
<h2 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>
<p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p>
<ul>
<li>从远程仓库下载本地仓库中缺失的提交记录</li>
<li>更新远程分支指针(如 <code>o/master</code>)</li>
</ul>
<p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>
<p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>master</code> 分支，也不会修改你磁盘上的文件</p>
<h2 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h2><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p>
<p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>
<ul>
<li><code>git cherry-pick o/master</code></li>
<li><code>git rebase o/master</code></li>
<li><code>git merge o/master</code></li>
<li>等等</li>
</ul>
<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。<code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure>

<h2 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h2><p>远程仓库接收了 <code>C2</code>，远程仓库中的 <code>master</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o/master) 也同样被更新了。所有的分支都同步了！</p>
<h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><p>如果你是在一个大的合作团队中工作, 很可能是master被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地master, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [远程服务器拒绝] master -&gt; master (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure>

<p>远程服务器拒绝直接推送(push)提交到master, 因为策略配置要求 pull requests 来提交更新.你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了master.现在你卡住并且无法推送你的更新.<strong>新建一个分支feature, 推送到远程服务器. 然后reset你的master分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题</strong>.</p>
<h2 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h2><p>在大型项目中开发人员通常会在（从 <code>master</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。</p>
<p>但是有些开发人员只在 master 上做 push、pull —— 这样的话 master 总是最新的，始终与远程分支 (o/master) 保持一致。</p>
<p>对于接下来这个工作流，我们集成了两个步骤：</p>
<ul>
<li>将特性分支集成到 <code>master</code> 上</li>
<li>推送并更新远程分支</li>
</ul>
<h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 <code>master</code> 与 <code>o/master</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 master 和本地的 master 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>
<ul>
<li>pull 操作时, 提交记录会被先下载到 o/master 上，之后再合并到本地的 master 分支。隐含的合并目标由这个关联确定的。</li>
<li>push 操作时, 我们把工作从 <code>master</code> 推到远程仓库中的 <code>master</code> 分支(同时会更新远程分支 <code>o/master</code>) 。这个推送的目的地也是由这种关联确定的！</li>
</ul>
<p><strong>远程跟踪</strong></p>
<p>直接了当地讲，<code>master</code> 和 <code>o/master</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>master</code> 被设定为跟踪 <code>o/master</code> —— 这意味着为 <strong><code>master</code> 分支指定了推送的目的地以及拉取后合并的目标。</strong></p>
<p>你可能想知道 <code>master</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>
<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/master</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>master</code>。</p>
<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>
<p>这也解释了为什么会在克隆的时候会看到下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;master&quot; set to track remote branch &quot;o&#x2F;master&quot;</span><br></pre></td></tr></table></figure>

<p><strong>我能自己指定这个属性吗？</strong></p>
<p>当然可以啦！你可以让任意分支跟踪 <code>o/master</code>, 然后该分支会像 <code>master</code> 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 <code>totallyNotMaster</code> 上执行 <code>git push</code>，将工作推送到远程仓库的 <code>master</code> 分支上。</p>
<p>有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMaster o&#x2F;master</span><br></pre></td></tr></table></figure>

<p>就可以创建一个名为 <code>totallyNotMaster</code> 的分支，它跟踪远程分支 <code>o/master</code>。</p>
<p><strong>第二种方法</strong></p>
<p>另一种设置远程追踪分支的方法就是使用：<code>git branch -u</code> 命令，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o&#x2F;master foo</span><br></pre></td></tr></table></figure>

<p>这样 <code>foo</code> 就会跟踪 <code>o/master</code> 了。如果当前就在 foo 分支上, 还可以省略 foo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o&#x2F;master</span><br></pre></td></tr></table></figure>

<h2 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h2><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;place&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;place&gt;</code> 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>把这个命令翻译过来就是：</p>
<p><em>切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p>
<p>我们通过“place”参数来告诉 Git 提交记录来自于 master, 要推送到远程仓库中的 master。它实际就是要同步的两个仓库的位置。需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</p>
<p><strong><code>&lt;place&gt;</code>参数详解</strong>：</p>
<p>还记得之前课程说的吧，当为 git push 指定 place 参数为 <code>master</code> 时，我们同时指定了提交记录的来源和去向。</p>
<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p>
<p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure>

<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了</p>
<h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><p><code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>
<p>如果你像如下命令这样为 git fetch 设置 的话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure>

<p>Git 会到远程仓库的 <code>foo</code> 分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code> 上。</p>
<p>为何 Git 会将新提交放到 <code>o/foo</code> 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code>课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p>
<p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前检出的分支上干这个事，但是其它分支是可以的。这里有一点是需要注意的 —— <code>source</code> 现在指的是远程仓库中的位置，而 <code>&lt;destination&gt;</code> 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 <code>fetch</code> 和 <code>push</code> 的相似性，只是方向相反罢了。</p>
<h2 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h2><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>
<ul>
<li><code>git push origin :side</code></li>
<li><code>git fetch origin :bugFix</code></li>
</ul>
<p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p>
<p>如果 fetch 空 到本地，会在本地创建一个新分支。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>……</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">梦永</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wmy1696.github.io/posts/44799/">https://wmy1696.github.io/posts/44799/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wmy1696.github.io" target="_blank">梦永の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post_share"><div class="social-share" data-image="https://github.com/Snailclimb/JavaGuide/raw/master/docs/operating-system/images/Linux-Logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/859/"><img class="prev-cover" data-src="https://42f2671d685f51e10fc6-b9fcecea3e50b3b59bdc28dead054ebc.ssl.cf5.rackcdn.com/illustrations/revenue_3osh.svg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Studio快捷键</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/posts/42790/" title="Android Studio搭配Git"><img class="relatedPosts_cover" data-src="https://42f2671d685f51e10fc6-b9fcecea3e50b3b59bdc28dead054ebc.ssl.cf5.rackcdn.com/illustrations/dashboard_nklg.svg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-15</div><div class="relatedPosts_title">Android Studio搭配Git</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'U2WgolDqadjJIRFIPiGknoQG-gzGzoHsz',
      appKey: '0KffzRG0l17lwF7QwYKcG1iC',
      placeholder: '记得留下你的暱称和邮箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      requiredFields: requiredFields
    });
  }
  loadScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || false) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 梦永</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><meta name="generator" content="Hexo 4.2.0"></head></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script src="/js/calendar.js"></script><script src="/js/languages.js"></script></body></html>