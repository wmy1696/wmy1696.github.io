<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基础</title>
      <link href="posts/18445/"/>
      <url>posts/18445/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.runoob.com/linux/linux-tutorial.html" target="_blank" rel="noopener">Linux教程</a></p></blockquote><h2 id="Linux-文件系统简介"><a href="#Linux-文件系统简介" class="headerlink" title="Linux 文件系统简介"></a>Linux 文件系统简介</h2><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p><p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p><h2 id="inode-介绍"><a href="#inode-介绍" class="headerlink" title="inode 介绍"></a>inode 介绍</h2><p><strong>inode 是 linux/unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p><p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p><p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p><p><strong>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息</strong>。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p><p>简单来说：<strong>inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</strong></p><p>简单总结一下：</p><ul><li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li><li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li></ul><h2 id="Linux-文件类型"><a href="#Linux-文件类型" class="headerlink" title="Linux 文件类型"></a>Linux 文件类型</h2><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p><ul><li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li><li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li><li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li><li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如硬盘。</li><li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li><li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li><li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li></ul><h2 id="Linux-目录树"><a href="#Linux-目录树" class="headerlink" title="Linux 目录树"></a>Linux 目录树</h2><p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p><p><strong>Linux 的目录结构如下：</strong></p><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：</p><p><img src= "/img/loading.gif" data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/operating-system/images/Linux%E7%9B%AE%E5%BD%95%E6%A0%91.png" alt=""></p><p><strong>常见目录说明：</strong></p><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li></ul><h2 id="Linux-基本命令"><a href="#Linux-基本命令" class="headerlink" title="Linux 基本命令"></a>Linux 基本命令</h2><p>下面只是给出了一些比较常用的命令。推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p><p>Linux 命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul><li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li><li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li><li><strong><code>cd /</code>：</strong> 切换到系统根目录</li><li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li><li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li></ul><h3 id="目录的操作命令-增删改查"><a href="#目录的操作命令-增删改查" class="headerlink" title="目录的操作命令(增删改查)"></a>目录的操作命令(增删改查)</h3><ul><li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</p></li><li><p><strong><code>ls/ll</code></strong>（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</p></li><li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：</p><p>① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；</p><p>② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code> ；</p><p>③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</p></li><li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</p></li><li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置—剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</p></li><li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</p></li><li><p><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包。</p></li></ul><h3 id="文件的操作命令-增删改查"><a href="#文件的操作命令-增删改查" class="headerlink" title="文件的操作命令(增删改查)"></a>文件的操作命令(增删改查)</h3><ul><li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li><li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li><li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li><li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li></ul><h3 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h3><p><strong>1）打包并压缩文件：</strong></p><p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul><p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></strong></p><p><strong>2）解压压缩包：</strong></p><p>命令：<code>tar [-xvf] 压缩文件</code></p><p>其中：x：代表解压</p><p>示例：</p><ul><li>将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></li><li>将 /test 下的 test.tar.gz 解压到根目录/usr 下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C 代表指定解压的位置）</li></ul><h3 id="Linux-的权限命令"><a href="#Linux-的权限命令" class="headerlink" title="Linux 的权限命令"></a>Linux 的权限命令</h3><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p><p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p><p><img src= "/img/loading.gif" data-src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/operating-system/images/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB.png" alt=""></p><p><strong>文件的类型：</strong></p><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是 window 中的快捷方式）</li></ul><p><strong>Linux 中权限分为以下几种：</strong></p><ul><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以使用 cat 查看文件的内容</td></tr><tr><td>w</td><td>可以修改文件的内容</td></tr><tr><td>x</td><td>可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以查看目录下列表</td></tr><tr><td>w</td><td>可以创建和删除目录下文件</td></tr><tr><td>x</td><td>可以使用 cd 进入目录</td></tr></tbody></table><p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p><p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用<code>chown 用户名 文件名</code>来修改文件的所有者 。</li><li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用<code>chgrp 组名 文件名</code>来修改文件所在的组。</li><li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li></ul><blockquote><p>我们再来看看如何修改文件/目录的权限。</p></blockquote><p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p><p>示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p><p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p><h3 id="Linux-用户管理"><a href="#Linux-用户管理" class="headerlink" title="Linux 用户管理"></a>Linux 用户管理</h3><p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><strong>Linux 用户管理相关命令:</strong></p><ul><li><code>useradd 选项 用户名</code>:添加用户账号</li><li><code>userdel 选项 用户名</code>:删除用户帐号</li><li><code>usermod 选项 用户名</code>:修改帐号</li><li><code>passwd 用户名</code>:更改或创建用户的密码</li><li><code>passwd -S 用户名</code> :显示用户账号密码信息</li><li><code>passwd -d 用户名</code>: 清除用户密码</li></ul><p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p><p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h3 id="Linux-系统用户组的管理"><a href="#Linux-系统用户组的管理" class="headerlink" title="Linux 系统用户组的管理"></a>Linux 系统用户组的管理</h3><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><p><strong>Linux 系统用户组的管理相关命令:</strong></p><ul><li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li><li><code>groupdel 用户组</code>:要删除一个已有的用户组</li><li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li></ul><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul><li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p></li><li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p></li><li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color 代表高亮显示</p></li><li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p><p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p></li><li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p><p>先用 ps 查找进程，然后用 kill 杀掉</p></li><li><p><strong>网络通信命令：</strong></p><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping</li><li>查看当前系统的端口使用：netstat -an</li></ul></li><li><p><strong>net-tools 和 iproute2 ：</strong> <code>net-tools</code>起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener">如何在 Linux 中使用 IP 命令和示例</a></p></li><li><p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p></li><li><p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《重构》笔记二</title>
      <link href="posts/46705/"/>
      <url>posts/46705/</url>
      
        <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装记录"><a href="#封装记录" class="headerlink" title="封装记录"></a>封装记录</h2>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《重构》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>效率工具</title>
      <link href="posts/55426/"/>
      <url>posts/55426/</url>
      
        <content type="html"><![CDATA[<h2 id="windows远程桌面"><a href="#windows远程桌面" class="headerlink" title="windows远程桌面"></a>windows远程桌面</h2><p>win10需要升级到专业版：</p><ul><li>点击开始图标，选择设置</li><li>选择更新和安全</li><li>选择激活，更改产品密钥</li></ul><p>被控制方设置:</p><ol><li>打开系统属性（win+pause）</li><li>进入远程设置</li><li>在远程协助里勾选允许远程协助连接计算，在远程桌面桌面上选择允许运行任意版本远程桌面的计算机连接</li><li>进入用户管理界面，设置账号和密码（必须设置密码）</li><li>查看本机ip</li></ol><p>控制方:</p><ol><li>打开远程桌面连接（运行-&gt;mstsc）</li><li>输入被控制方的ip地址，然后连接，连接成功之后再输入账号和密码即可</li></ol><h2 id="windows-sandbox"><a href="#windows-sandbox" class="headerlink" title="windows sandbox"></a>windows sandbox</h2><p>Windows Sandbox正是为“<strong>安全地运行应用程序</strong>”而量身定制。用户可以在这个<strong>独立</strong>且<strong>封闭</strong>的<strong>临时</strong>桌面环境里，运行<strong>不受信任的软件</strong>比如未知的exe文件，不会对宿主机系统造成任何影响。因为 Windows Sandbox 中安装的任何软件以及做出的任何文件变动，下次启动时将不复存在。</p><p><strong>开启功能</strong>:<br>Windows Sandbox功能需要在18305及更高版本的系统中手动开启，具体路径为<strong>控制面板</strong> → <strong>程序和功能</strong> → <strong>启用或关闭Windows功能</strong> → <strong>勾选Windows Sandbox</strong>。</p><h2 id="windows-WSL"><a href="#windows-WSL" class="headerlink" title="windows WSL"></a>windows WSL</h2><blockquote><p>WSL 可以让你访问 Windows 上的 Linux Bash shell。</p></blockquote><p>前往 “启用或关闭 Windows 功能” ，然后滚动至底部，如截图所示，勾选 “适用于 Linux 的 Windows 子系统”，点击确定。它将会下载安装需要的包。</p><p>在 Windows 中安装 Linux，有很多方式，这里我们选择一种最简单的方式。打开 Microsoft Store，搜索 Linux。下载安装一个就可以了。</p><p>我们Linux系统中的文件，在Windows中如何访问呢？在Linux下执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;home     </span><br><span class="line">explorer.exe .</span><br></pre></td></tr></table></figure><p>上面的命令，即可打开Linux目录对应的Windows目录，从文件管理器中我们就可以访问到。为了操作方便，我把这个长长的目录，映射到了Z盘上。如图，下次在访问Linux的时候，直接访问Z盘就可以了。</p><h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><p>先用 <code>sudo apt install zsh</code>安装shell终端，然后运行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c  &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012814856/article/details/100668640" target="_blank" rel="noopener">如何在没有网络的情况下离线安装oh_my_zsh</a></p><p><a href="https://www.jianshu.com/p/d372ef933453" target="_blank" rel="noopener">oh-my-zsh 配置插件</a></p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p><a href="https://code.visualstudio.com/docs/" target="_blank" rel="noopener">官网手册</a></p><p><a href="https://blog.csdn.net/mrbone11/article/details/104194196" target="_blank" rel="noopener">vscode-同步配置</a></p>]]></content>
      
      
      <categories>
          
          <category> 效率工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程入门</title>
      <link href="posts/40666/"/>
      <url>posts/40666/</url>
      
        <content type="html"><![CDATA[<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><p>Shell编程就是对一堆Linux命令的逻辑化处理</p><h3 id="Shell-编程的-Hello-World"><a href="#Shell-编程的-Hello-World" class="headerlink" title="Shell 编程的 Hello World"></a>Shell 编程的 Hello World</h3><p>学习任何一门编程语言第一件事就是输出HelloWord了！</p><p>(1)新建一个文件 helloworld.sh :<code>touch helloworld.sh</code>，扩展名为 sh（sh代表Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）</p><p>(2) 使脚本具有执行权限：<code>chmod +x helloworld.sh</code></p><p>(3) 使用 vim 命令修改helloworld.sh文件：<code>vim helloworld.sh</code>(vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）)</p><p>helloworld.sh 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#第一个shell小程序,echo 是linux中的输出命令。</span><br><span class="line">echo  &quot;helloworld!&quot;</span><br></pre></td></tr></table></figure><p>shell中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在linux中，除了bash shell以外，还有很多版本的shell， 例如zsh、dash等等…不过bash shell还是我们使用最多的。</strong></p><p>(4) 运行脚本:<code>./helloworld.sh</code> 。（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 helloworld.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p><h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><h3 id="Shell-编程中的变量介绍"><a href="#Shell-编程中的变量介绍" class="headerlink" title="Shell 编程中的变量介绍"></a>Shell 编程中的变量介绍</h3><p><strong>Shell编程中一般分为三种变量：</strong></p><ol><li><strong>我们自己定义的变量（自定义变量）:</strong> 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。</li><li><strong>Linux已定义的环境变量</strong>（环境变量， 例如：$PATH, $HOME 等…, 这类变量我们可以直接使用），使用 <code>env</code> 命令可以查看所有的环境变量，而set命令既可以查看环境变量也可以查看自定义变量。</li><li><strong>Shell变量</strong> ：Shell变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行</li></ol><p><strong>常用的环境变量:</strong></p><blockquote><p>PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE　历史记录数 LOGNAME 当前用户的登录名 HOSTNAME　指主机的名称 SHELL 当前用户Shell类型 LANGUGE 　语言相关的环境变量，多语言可以修改此环境变量 MAIL　当前用户的邮件存放目录 PS1　基本提示符，对于root用户是#，对于普通用户是$</p></blockquote><p><strong>使用 Linux 已定义的环境变量：</strong></p><p>比如我们要看当前用户目录可以使用：<code>echo $HOME</code>命令；如果我们要看当前用户Shell类型 可以使用<code>echo $SHELL</code>命令。可以看出，使用方法非常简单。</p><p><strong>使用自己定义的变量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#自定义变量hello</span><br><span class="line">hello&#x3D;&quot;hello world&quot;</span><br><span class="line">echo $hello</span><br><span class="line">echo  &quot;helloworld!&quot;</span><br></pre></td></tr></table></figure><p><strong>Shell 编程中的变量名的命名的注意事项：</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h3 id="Shell-字符串入门"><a href="#Shell-字符串入门" class="headerlink" title="Shell 字符串入门"></a>Shell 字符串入门</h3><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和Java中有所不同。</p><p><strong>单引号字符串：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&#39;SnailClimb&#39;</span><br><span class="line">hello&#x3D;&#39;Hello, I  am &#39;$name&#39;!&#39;</span><br><span class="line">echo $hello</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am SnailClimb!</span><br></pre></td></tr></table></figure><p><strong>双引号字符串：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&#39;SnailClimb&#39;</span><br><span class="line">hello&#x3D;&quot;Hello, I  am &quot;$name&quot;!&quot;</span><br><span class="line">echo $hello</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am SnailClimb!</span><br></pre></td></tr></table></figure><h3 id="Shell-字符串常见操作"><a href="#Shell-字符串常见操作" class="headerlink" title="Shell 字符串常见操作"></a>Shell 字符串常见操作</h3><p><strong>拼接字符串：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&quot;SnailClimb&quot;</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting&#x3D;&quot;hello, &quot;$name&quot; !&quot;</span><br><span class="line">greeting_1&#x3D;&quot;hello, $&#123;name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting_2&#x3D;&#39;hello, &#39;$name&#39; !&#39;</span><br><span class="line">greeting_3&#x3D;&#39;hello, $&#123;name&#125; !&#39;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure><p><strong>获取字符串长度：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#获取字符串长度</span><br><span class="line">name&#x3D;&quot;SnailClimb&quot;</span><br><span class="line"># 第一种方式</span><br><span class="line">echo $&#123;#name&#125; #输出 10</span><br><span class="line"># 第二种方式</span><br><span class="line">expr length &quot;$name&quot;;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr 5+6    &#x2F;&#x2F; 直接输出 5+6</span><br><span class="line">expr 5 + 6       &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure><p>对于某些运算符，还需要我们使用符号<code>\</code>进行转义，否则就会提示语法错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr 5 * 6       &#x2F;&#x2F; 输出错误</span><br><span class="line">expr 5 \* 6      &#x2F;&#x2F; 输出30</span><br></pre></td></tr></table></figure><p><strong>截取子字符串:</strong></p><p>简单的字符串截取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#从字符串第 1 个字符开始往后截取 10 个字符</span><br><span class="line">str&#x3D;&quot;SnailClimb is a great man&quot;</span><br><span class="line">echo $&#123;str:0:10&#125; #输出:SnailClimb</span><br></pre></td></tr></table></figure><p>根据表达式截取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!bin&#x2F;bash</span><br><span class="line">#author:amau</span><br><span class="line"></span><br><span class="line">var&#x3D;&quot;http:&#x2F;&#x2F;www.runoob.com&#x2F;linux&#x2F;linux-shell-variable.html&quot;</span><br><span class="line"></span><br><span class="line">s1&#x3D;$&#123;var%%t*&#125;#h</span><br><span class="line">s2&#x3D;$&#123;var%t*&#125;#http:&#x2F;&#x2F;www.runoob.com&#x2F;linux&#x2F;linux-shell-variable.h</span><br><span class="line">s3&#x3D;$&#123;var%%.*&#125;#http:&#x2F;&#x2F;www</span><br><span class="line">s4&#x3D;$&#123;var#*&#x2F;&#125;#&#x2F;www.runoob.com&#x2F;linux&#x2F;linux-shell-variable.html</span><br><span class="line">s5&#x3D;$&#123;var##*&#x2F;&#125;#linux-shell-variable.html</span><br></pre></td></tr></table></figure><h3 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取/删除特定位置的数组元素、删除整个数组以及遍历数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">array&#x3D;(1 2 3 4 5);</span><br><span class="line"># 获取数组长度</span><br><span class="line">length&#x3D;$&#123;#array[@]&#125;</span><br><span class="line"># 或者</span><br><span class="line">length2&#x3D;$&#123;#array[*]&#125;</span><br><span class="line">#输出数组长度</span><br><span class="line">echo $length #输出：5</span><br><span class="line">echo $length2 #输出：5</span><br><span class="line"># 输出数组第三个元素</span><br><span class="line">echo $&#123;array[2]&#125; #输出：3</span><br><span class="line">unset array[1]# 删除下标为1的元素也就是删除第二个元素</span><br><span class="line">for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，输出： 1 3 4 5 </span><br><span class="line">unset arr_number; # 删除数组中的所有元素</span><br><span class="line">for i in $&#123;array[@]&#125;;do echo $i ;done # 遍历数组，数组元素为空，没有任何输出内容</span><br></pre></td></tr></table></figure><h2 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h2><blockquote><p>说明：图片来自《菜鸟教程》</p></blockquote><p>Shell 编程支持下面几种运算符</p><ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><a href="https://camo.githubusercontent.com/b06d8580b2ce438eeffcb6b91f4031bdab03723d/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f343933373334322e6a7067" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://camo.githubusercontent.com/b06d8580b2ce438eeffcb6b91f4031bdab03723d/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f343933373334322e6a7067" alt="算数运算符"></a></p><p>我以加法运算符做一个简单的示例（注意：不是单引号，是反引号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;3;b&#x3D;3;</span><br><span class="line">val&#x3D;&#96;expr $a + $b&#96;</span><br><span class="line">#输出：Total value : 6</span><br><span class="line">echo &quot;Total value : $val&quot;</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p><a href="https://camo.githubusercontent.com/d5195686adb0ce5ce4674e0034ef1f340db5d1f8/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f36343339313338302e6a7067" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://camo.githubusercontent.com/d5195686adb0ce5ce4674e0034ef1f340db5d1f8/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f36343339313338302e6a7067" alt="shell关系运算符"></a></p><p>通过一个简单的示例演示关系运算符的使用，下面shell程序的作用是当score=100的时候输出A否则输出B。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">score&#x3D;90;</span><br><span class="line">maxscore&#x3D;100;</span><br><span class="line">if [ $score -eq $maxscore ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;A&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;B&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><a href="https://camo.githubusercontent.com/270bcf3c50a6dde6ecc7f8a84c36c14a9e5db8f8/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f36303534353834382e6a7067" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://camo.githubusercontent.com/270bcf3c50a6dde6ecc7f8a84c36c14a9e5db8f8/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f36303534353834382e6a7067" alt="逻辑运算符"></a></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;$(( 1 &amp;&amp; 0))</span><br><span class="line"># 输出：0；逻辑与运算只有相与的两边都是1，与的结果才是1；否则与的结果是0</span><br><span class="line">echo $a;</span><br></pre></td></tr></table></figure><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p><a href="https://camo.githubusercontent.com/1ab695e350fead23c005f78de7c62cde0fd952b3/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f39333936313432352e6a7067" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://camo.githubusercontent.com/1ab695e350fead23c005f78de7c62cde0fd952b3/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f39333936313432352e6a7067" alt="布尔运算符"></a></p><p>这里就不做演示了，应该挺简单的。</p><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p><a href="https://camo.githubusercontent.com/912c85243f5ad71cac99ffcca85a3760322ff9cd/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f3330393039342e6a7067" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://camo.githubusercontent.com/912c85243f5ad71cac99ffcca85a3760322ff9cd/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f3330393039342e6a7067" alt=" 字符串运算符"></a></p><p>简单示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;&quot;abc&quot;;</span><br><span class="line">b&#x3D;&quot;efg&quot;;</span><br><span class="line">if [ $a &#x3D; $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 不等于 b</span><br></pre></td></tr></table></figure><h3 id="文件相关运算符"><a href="#文件相关运算符" class="headerlink" title="文件相关运算符"></a>文件相关运算符</h3><p><a href="https://camo.githubusercontent.com/e88a38785485a177a09343e00ec58e7ba20dd9d2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f36303335393737342e6a7067" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://camo.githubusercontent.com/e88a38785485a177a09343e00ec58e7ba20dd9d2/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31312d32322f36303335393737342e6a7067" alt="文件相关运算符"></a></p><p>使用方式很简单，比如我们定义好了一个文件路径<code>file=&quot;/usr/learnshell/test.sh&quot;</code> 如果我们想判断这个文件是否可读，可以这样<code>if [ -r $file ]</code> 如果想判断这个文件是否可写，可以这样<code>-w $file</code>，是不是很简单。</p><h2 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h2><h3 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h3><p>简单的 if else-if else 的条件语句示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">a&#x3D;3;</span><br><span class="line">b&#x3D;9;</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 小于 b</span><br></pre></td></tr></table></figure><p>相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell if 条件语句中不能包含空语句也就是什么都不做的语句。</p><h3 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h3><p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p><p><strong>输出当前列表中的数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>产生 10 个随机数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#123;0..9&#125;;</span><br><span class="line">do </span><br><span class="line">   echo $RANDOM;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>输出1到5:</strong></p><p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for((i&#x3D;1;i&lt;&#x3D;5;i++));do</span><br><span class="line">    echo $i;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p><strong>基本的 while 循环语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">int&#x3D;1</span><br><span class="line">while(( $int&lt;&#x3D;5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>while循环可用于读取键盘信息：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;按下 &lt;CTRL-D&gt; 退出&#39;</span><br><span class="line">echo -n &#39;输入你最喜欢的电影: &#39;</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo &quot;是的！$FILM 是一个好电影&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">输入你最喜欢的电影: 变形金刚</span><br><span class="line">是的！变形金刚 是一个好电影</span><br></pre></td></tr></table></figure><p><strong>无限循环：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><h3 id="不带参数没有返回值的函数"><a href="#不带参数没有返回值的函数" class="headerlink" title="不带参数没有返回值的函数"></a>不带参数没有返回值的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">hello()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;-----函数开始执行-----&quot;</span><br><span class="line">hello</span><br><span class="line">echo &quot;-----函数执行完毕-----&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure><h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><p><strong>输入两个数字之后相加并返回结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $?&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3</span><br></pre></td></tr></table></figure><h3 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache服务器</title>
      <link href="posts/45136/"/>
      <url>posts/45136/</url>
      
        <content type="html"><![CDATA[<h2 id="Apache-和-Tomcat-服务器"><a href="#Apache-和-Tomcat-服务器" class="headerlink" title="Apache 和 Tomcat 服务器"></a>Apache 和 Tomcat 服务器</h2><p>Apache是Web服务器（静态解析，如HTML），Tomcat是Java应用服务器（动态解析，如JSP）。</p><p>Apache是普通Web服务器，只支持html(静态网页)，通过插件支持PHP，可以与Tomcat连通(Apache单向连接Tomcat，通过Apache可以访问Tomcat资源，反之不然)。Tomcat是JSP/servlet容器，同时也支持HTML、JSP、ASP、PHP、CGI等，其中CGI需要一些手动调试，不过很容易的。 两者都是Apache组织开发、都有HTTP服务的功能、都是开源免费。</p><p> 如果客户端请求的是静态页面，只需Apache服务器响应请求；如果客户端请求动态页面，则由Tomcat服务器响应请求，将解析的JSP等网页代码解析后回传给Apache服务器，再经Apache返回给客户端端。这是因为JSP是服务器端解释代码的，Tomcat只做动态代码解析，Apache回传解析好的静态代码，Apache+Tomcat整合可以减少Tomcat的服务开销。 </p><p>​    Apache由C语言实现，支持各种特性和模块从而来扩展核心功能；Tomcat由Java编写的，更好的支持Servlet和JSP。Apache可以运行一年不重启，稳定性非常好，而Tomcat则不见得。 Apache是最开始的页面解析服务，Tomcat是后研发出来的，从本质上来说Tomcat的功能完全可以替代Apache，但Apache毕竟是Tomcat的前辈级人物，并且市场上也有不少人还在用Apache，所以Apache还会继续存在，不会被取代，Apache不能解析java的东西，但解析html速度快。</p><h2 id="Apache下载安装"><a href="#Apache下载安装" class="headerlink" title="Apache下载安装"></a>Apache下载安装</h2><p>1、下载地址：<a href="https://httpd.apache.org/download.cgi" target="_blank" rel="noopener">https://httpd.apache.org/download.cgi</a></p><p>2、点击 Files for Microsoft Windows</p><p>修改配置文件：</p><p>1、打开安装路径下的 conf \ httpd.conf</p><p>2、将文件中所有的 “C:/Apache24” 替换成自己的安装目录，这边为 “E:/Apache/Apache24”</p><p>3、将 ServerName 前面的 # 去掉</p><p>4、找到 DocumentRoot ，修改网站的根目录，这边为 “E:/Apache/Apache24/htdocs”</p><p>5、修改端口号 80 为 8080</p><p>安装服务：</p><p>1、以管理员身份运行CMD，进入 “E:/Apache/Apache24/bin” 目录（ httpd.exe 所在目录）</p><p>2、输入 httpd.exe -k install -n “Apache24” 安装服务（Apache24 为服务的名称）</p><p>3、如果服务安装成功，则服务 Apache24 会出现</p><p>4、打开浏览器输入 <a href="http://localhost:8080/" target="_blank" rel="noopener">localhost:8080</a></p><p>卸载服务：</p><p>1、方法一：运行cmd，进入Apache程序所在目录</p><p>   输入：httpd –k uninstall</p><p>2、方法二：进入控制面板查看 Apache 程序的服务名（比如 Apache24）</p><p>   先停止服务：net stop Apache24</p><p>   再卸载服务：sc delete Apache24</p>]]></content>
      
      
      <categories>
          
          <category> Apache服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 技能树</title>
      <link href="posts/19452/"/>
      <url>posts/19452/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3><ol><li><p>Kotlin语言基础</p><ul><li><p>《Kotlin实战》</p></li><li><p><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">官网</a></p></li></ul></li><li><p>Java语言基础</p><ul><li>《Thinking in Java》</li><li>《Effective Java》</li></ul></li><li><p>C/C++</p><ul><li>《C++ Primer Plus》</li></ul></li><li><p>Python</p></li></ol><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><ul><li>《程序是怎么跑起来的》</li><li>《计算机是怎么跑起来的》</li></ul><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><ol><li>数据安全，加密原理</li><li>反劫持</li><li>传输协议与基本原理</li></ol><h3 id="存储与持久化"><a href="#存储与持久化" class="headerlink" title="存储与持久化"></a>存储与持久化</h3><ol><li>数据库Sqlite</li><li>文件IO</li><li>图片加载库，多级缓存</li></ol><h3 id="客户端并发"><a href="#客户端并发" class="headerlink" title="客户端并发"></a>客户端并发</h3><ol><li>多线程使用和数据安全</li><li>进程通信IPC</li></ol><h3 id="Android开发"><a href="#Android开发" class="headerlink" title="Android开发"></a>Android开发</h3><ol><li>Android Code Style</li><li>Android开发安全实践</li><li>Android应用概述</li><li>Android系统概述</li><li>系统基础<ul><li>Handler机制</li><li>进程、线程的本质</li><li>IPC机制</li></ul></li></ol><h2 id="工程能力"><a href="#工程能力" class="headerlink" title="工程能力"></a>工程能力</h2><h2 id="系统技术"><a href="#系统技术" class="headerlink" title="系统技术"></a>系统技术</h2><h2 id="Android-开源技术"><a href="#Android-开源技术" class="headerlink" title="Android 开源技术"></a>Android 开源技术</h2><h2 id="业务与工具"><a href="#业务与工具" class="headerlink" title="业务与工具"></a>业务与工具</h2><h2 id="持续更新"><a href="#持续更新" class="headerlink" title="持续更新"></a>持续更新</h2>]]></content>
      
      
      <categories>
          
          <category> Android技能树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习方向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《重构》笔记一</title>
      <link href="posts/54128/"/>
      <url>posts/54128/</url>
      
        <content type="html"><![CDATA[<h1 id="第一组重构"><a href="#第一组重构" class="headerlink" title="第一组重构"></a>第一组重构</h1><h2 id="提炼函数"><a href="#提炼函数" class="headerlink" title="提炼函数"></a>提炼函数</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>浏览一段代码，理解其作用，然后将其提炼到一个独立的函数中，并以这段代码的用途为这个函数命名。</p><p><strong>何时使用？</strong></p><p><strong>将意图与实现分开</strong>，弄清它到底做什么，根据它所做的事为其命名。</p><p>补充：写非常小的函数，不超过6行。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ol><li>创造一个新函数，根据这个函数的意图来对它命名（“做什么”）</li><li>将待提炼的代码从源函数复制到新建的目标函数中</li><li>检查提炼的代码，看看其中是否引用了作用域限于源函数、在提炼函数中访问不到的变量。若是，以参数的形式将它们传递给新的函数。</li><li>所有变量处理完之后，编译。</li><li>在源函数中，将被提炼代码段替换为对目标函数的调用</li><li>测试</li><li>查看其他代码是否有与被提炼的代码段相同或相似之处。若有，考虑使用以函数调用取代内联代码令其调用提炼出新的函数。</li></ol><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><ol><li><p>无局部变量：简单</p></li><li><p>有局部变量（只读取不改）：传递即可</p></li><li><p>对局部变量再赋值：拆分变量，将其变成临时变量</p><p>若被赋值的临时变量只在提炼代码中使用，一起提炼出去。</p><p>提炼代码之外也用到：首先把变量声明移动到使用处之前，然后把想要提炼的代码复制到目标函数中，修改原来代码，调用新函数。</p></li></ol><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>通过内联手法，找出有用的中间层，同时将无用的中间层去除。</p><h3 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h3><ol><li><p>检查函数，确定它不具多态性</p><p>如果该函数属于一个类，并且有子类继承了这个函数，那么无法内联。</p></li><li><p>找出这个函数所有调用点</p></li><li><p>将这个函数所有调用点替换为函数本体</p></li><li><p>每次替换之后，执行测试</p></li><li><p>删除该函数的定义</p></li></ol><h2 id="提炼变量"><a href="#提炼变量" class="headerlink" title="提炼变量"></a>提炼变量</h2><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>局部变量可以帮助我们将表达式分解为比较容易管理的形式。</p><h3 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h3><ol><li>确认要提炼的表达式没有副作用</li><li>声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值</li><li>用这个新变量取代原来的表达式</li><li>测试</li></ol><h2 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h2><h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>变量不比表达式更具表现力，通过内联手法消除变量</p><h3 id="做法-3"><a href="#做法-3" class="headerlink" title="做法"></a>做法</h3><ol><li>检查确认变量赋值语句的右侧表达式没有副作用</li><li>如果变量没有被声明为本可修改，先将其变为不可修改，并执行测试</li><li>找到第一处使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式</li><li>测试</li><li>重复前两步，逐一替换</li><li>删除该变量声明点和赋值语句</li><li>测试</li></ol><h2 id="改变函数声明"><a href="#改变函数声明" class="headerlink" title="改变函数声明"></a>改变函数声明</h2><h3 id="简单的做法"><a href="#简单的做法" class="headerlink" title="简单的做法"></a>简单的做法</h3><ol><li>如果想移除一个参数，需要先确定函数体内没有使用该参数</li><li>修改函数声明，使其成为你期望的状态</li><li>找出所有使用旧的函数声明的地方，将它们改为新的函数声明</li><li>测试</li></ol><h3 id="迁移式做法"><a href="#迁移式做法" class="headerlink" title="迁移式做法"></a>迁移式做法</h3><ol><li>如果有必要，先对函数体内部加以重构，使后面的提炼步骤易于开展</li><li>使用提炼函数将函数体提炼成一个新函数</li><li>如果提炼出的函数需要新增参数，用前面的简单做法添加即可</li><li>测试</li><li>如果新函数使用了临时的名字，再次改变函数声明将其改回原来的名字</li><li>测试</li></ol><p>自动化重构工具减少了迁移式做法的用武之地</p><h2 id="封装变量"><a href="#封装变量" class="headerlink" title="封装变量"></a>封装变量</h2><h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>如果想搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装所有对该数据的访问。</p><h3 id="做法-4"><a href="#做法-4" class="headerlink" title="做法"></a>做法</h3><ol><li>创建封装函数，在其中访问和更新变量值</li><li>执行静态检查</li><li>逐一修改使用该变量的代码，将其改为合适的封装函数。每次替换之后，执行测试</li><li>限制变量的可见性</li><li>测试</li><li>如果变量的值是一个记录，考虑使用封装记录</li></ol><h2 id="变量改名"><a href="#变量改名" class="headerlink" title="变量改名"></a>变量改名</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><ol><li>如果变量被广泛使用，考虑运用封装变量将其封装起来</li><li>找出所有使用该变量的代码，逐一修改</li><li>测试</li></ol><h2 id="引入参数对象"><a href="#引入参数对象" class="headerlink" title="引入参数对象"></a>引入参数对象</h2><h3 id="做法-5"><a href="#做法-5" class="headerlink" title="做法"></a>做法</h3><ol><li><p>如果暂时还没有一个合适的数据结构，就创建一个</p><p>倾向使用类，因为稍后把行为放进来比较容易</p></li><li><p>测试</p></li><li><p>使用改变函数声明给原来的函数新增一个参数，类型是新建的数据结构</p></li><li><p>测试</p></li><li><p>调整所有调用者，传入新数据结构的适当实例。每修改一处，执行测试</p></li><li><p>用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数，测试</p></li></ol><h2 id="函数组合成类"><a href="#函数组合成类" class="headerlink" title="函数组合成类"></a>函数组合成类</h2><h3 id="做法-6"><a href="#做法-6" class="headerlink" title="做法"></a>做法</h3><p>类似JavaBean的封装</p><ol><li>运用封装记录对多个函数共用的数据记录加以封装</li><li>对于使用该记录的每个函数，运用搬移函数将其移入新类</li><li>用以处理该数据记录的逻辑可以用提炼函数提炼出来，并移入新类。</li></ol><h2 id="函数组合成变换"><a href="#函数组合成变换" class="headerlink" title="函数组合成变换"></a>函数组合成变换</h2><h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><p>把所有计算派生数据的逻辑收拢到一处，避免到处重复。</p><p>函数组合变换的替代方案是函数组合成类，区别：如果代码中会对源数据做更新，那么使用类要好的多，如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据修改，造成数据不一致。</p><h3 id="做法-7"><a href="#做法-7" class="headerlink" title="做法"></a>做法</h3><ol><li><p>创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。</p><p>对输入记录深拷贝</p></li><li><p>挑选一块逻辑，将其主体移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段</p></li><li><p>测试</p></li><li><p>针对其他相关计算逻辑，重复上述步骤</p></li></ol><h2 id="拆分阶段"><a href="#拆分阶段" class="headerlink" title="拆分阶段"></a>拆分阶段</h2><h3 id="做法-8"><a href="#做法-8" class="headerlink" title="做法"></a>做法</h3><ol><li>将第二阶段的代码提炼成独立的函数</li><li>测试</li><li>引入一个中转数据结构，将其作为参数添加到提炼出的新函数参数列表</li><li>测试</li><li>逐一检查提炼出的“第二阶段函数”的每个参数。如果某个参数被第一阶段用到，就将其移入中转数据结构中。每次搬迁之后都要执行测试。</li><li>对第一阶段的代码运用提炼函数，让提炼出的函数返回中转数据结构。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《重构》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 学习路线</title>
      <link href="posts/19779/"/>
      <url>posts/19779/</url>
      
        <content type="html"><![CDATA[<h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java 是 Android App 开发默认的语言, Android Framework 也是默认使用 Java 语言，熟练掌握 Java 语言是 Android 开发者的必备技能。</p><ol><li>周志明的《深入理解Java虚拟机（第3版）》</li><li>邓老师的 《深入理解Android Java 虚拟机 ART》</li><li>Effective Java</li></ol><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Google 几年前就开始走 “Kotlin First” 的路线，目前很多官方的文档和 Demo 都是使用 Kotlin 语言作为默认，Kotlin 的重要性不言而喻。</p><p>Google 官方也出了个<a href="https://link.zhihu.com/?target=https%3A//clmirror.storage.googleapis.com/codelabs/java-to-kotlin-zh/index.html%230">“Refactoring to Kotlin”</a>的教程,其介绍如下：</p><blockquote><p>此 Codelab 的适用对象为任何使用 Java 并考虑将其项目迁移到 Kotlin 的开发者。我们将从数个 Java 类入手，引导您使用 IDE 将它们转换为 Kotlin。接着，我们会审视转换后的代码，研究如何加以改善，使其更符合使用习惯，同时避免常见错误</p></blockquote><p><a href="https://link.zhihu.com/?target=https%3A//clmirror.storage.googleapis.com/codelabs/java-to-kotlin-zh/index.html%230">Refactoring to Kotlin</a></p><h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p><a href="https://link.zhihu.com/?target=https%3A//github.com/flutter/flutter">Flutter</a> 作为 Google 的亲儿子，其官方的扶持力度大家有目共睹。</p><p>Flutter 的发展大家可以看一下 Gityuan 的这一篇<a href="https://link.zhihu.com/?target=http%3A//gityuan.com/flutter/">Flutter 跨平台演进及架构开篇</a>,目前字节跳动的多个 App 已经接入 Flutter 进行混合开发。</p><ul><li><input disabled="" type="checkbox"> 待学习了解</li></ul><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><h3 id="Android-Studio-IDE-Overview"><a href="#Android-Studio-IDE-Overview" class="headerlink" title="Android Studio IDE Overview"></a>Android Studio IDE Overview</h3><p>Android Studio 作为 Android 默认的开发者工具，目前的版本更新已经解决了诸多之前的性能问题，虽然目前对硬件资源的要求仍然比较高，但是一旦你接受了这个设定，真香预警！</p><p>AS 主要需要熟悉下面几点</p><ol><li>AS 快捷键</li><li>AS 插件</li><li>AS Profile （内存、CPU、IO、NetWork）</li></ol><h3 id="Project-Structure-—-Java-Kotlin-Flutter-XML-gradle-files"><a href="#Project-Structure-—-Java-Kotlin-Flutter-XML-gradle-files" class="headerlink" title="Project Structure — Java/Kotlin/Flutter, XML, .gradle files"></a>Project Structure — Java/Kotlin/Flutter, XML, .gradle files</h3><p>熟悉各种项目的目录结构，资源文件、Gradle 文件</p><h2 id="Android-基础知识"><a href="#Android-基础知识" class="headerlink" title="Android 基础知识"></a>Android 基础知识</h2><h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><ol><li>Activity — Activity Lifecycle, Tasks &amp; Back Stack</li><li>Service</li><li>Broadcast Receiver</li><li>Content Provider</li></ol><h3 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h3><ol><li>Types of Intent - Implicit, Explicit</li><li>Intent Filter</li></ol><h3 id="Static-User-Interface"><a href="#Static-User-Interface" class="headerlink" title="Static User Interface"></a>Static User Interface</h3><ol><li>View — Button, ImageView, TextView, EditText, and etc :这是开发中会遇到的常用的组件，许多复杂的布局都是用简单基础的 View 组合而成</li><li>ViewGroup - LinearLayout, RelativeLayout, FrameLayout:三大传统布局，适用于不同的场合</li><li>ConstraintLayout : Google 新推的布局，目前已经取代 RelativeLayout 成为默认的 App 布局，具体使用可以参考<a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/support/constraint/ConstraintLayout%3Fhl%3Dzh-cn">官方文档</a></li></ol><h3 id="Dynamic-User-Interface"><a href="#Dynamic-User-Interface" class="headerlink" title="Dynamic User Interface"></a>Dynamic User Interface</h3><ol><li><p>RecyclerView - 列表类的布局首选控件，性能相对 ListView 要好一些，功能也比 ListView 要多一</p></li><li><p>ViewPager</p></li><li><p>Spinner</p></li></ol><h3 id="CustomView"><a href="#CustomView" class="headerlink" title="CustomView"></a>CustomView</h3><p>Android 默认的布局很多时候都没法满足设计的需求，这时候就需要<strong>自定义 View</strong>，你需要掌握下面几个知识点的使用</p><ol><li>Canvas</li><li>Bitmap</li><li>Paint</li></ol><h3 id="UI-Resources"><a href="#UI-Resources" class="headerlink" title="UI Resources"></a>UI Resources</h3><p>相比 HardCode，使用资源文件会让代码的可修改性更高</p><ol><li>Drawables</li><li>String</li><li>Styles</li></ol><h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><p>许多人提倡 App 使用 单 Activity + 多个 Fragment 的组合，可见 Fragment 在开发中的重要性，但是 Fragment 的管理又是一门技术，Fragment 的坑，只能在实际开发中慢慢填平了，不过下面的 Fragment 基础还是要牢固</p><ol><li>Fragment Lifecycle</li><li>Fragment Manager</li></ol><h3 id="Support-User-Interface"><a href="#Support-User-Interface" class="headerlink" title="Support User Interface"></a>Support User Interface</h3><p>这里列的同样是一些功能组件，需要知道这是什么东西，基本的用法</p><ol><li>ProgressBar - 进度条</li><li>Dialogs - 弹框</li><li>Toast &amp; Snackbar - 提示</li></ol><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>App 开发不免要和文件打交道，文件的读写、存储都是必不可少的，下面列出了几种 Android 中存储相关的知识点</p><ol><li>Shared Preferences - 适合存储字段</li><li>File Systems - 文件存储</li><li>Database — RoomDB - 数据库存储，RoomDB 是 Google 新推出的数据库解决方案(在 AndroidX 中)，具体使用可以参考<a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/room/RoomDatabase.html">官方文档</a></li></ol><h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>Android App 默认使用 Gradle 进行编译，关于 Gradle 的使用必须要熟悉，以及如何区分开发版本和 Release 版本，以及国内特有的多渠道打包技术、以及 ASM 等</p><ol><li>Gradle</li><li>Debug / Release Configuration</li><li>多渠道打包</li><li>ASM</li></ol><h3 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h3><p>理解 Thread 非常重要，Android App 只有一个主线程，其余的我们称之为工作线程，我们的很多工作需要再工作线程和主线程直接切换，如何高效创建和释放线程、线程池、线程间通信、Message-Looper-Handler 模型这些知识点都要了熟于心，另外进阶的话 Binder 通信也是需要掌握的知识</p><ol><li>Threads</li><li>Handler / Looper / Message / MessageQueue</li><li>AIDL / Binder</li></ol><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><p>这里列举了一些 Debug 的基本手段，实际开发中遇到具体问题的时候一般都会用到，不过有的可能入手难度要高一些，需要花时间去掌握。Debug 工具除了下面这几个还有很多</p><ol><li>Memory profiling - MAT，AS Memory Profile</li><li>Logging - Log 包含非常丰富的信息，可以帮助我们还原现场</li><li>Systrace - Systrace 工具可以查看一段时间内手机系统各个进程的运行状态，具体使用可以参考我博客的 </li><li>Exceptions - 各种异常，保证程序的健壮性</li><li>Error Handling - Error 是必须要解决的问题，一般会导致 App 直接闪退，需要非常重视</li></ol><h2 id="Memory-Leak"><a href="#Memory-Leak" class="headerlink" title="Memory Leak"></a>Memory Leak</h2><p>内存泄漏是一个很大的专题，包括 Java 内容泄漏和 Native 内存泄漏，涉及的知识点非常多，可以单独拿出来做一个大的知识栈。一般来说， Java 内存泄漏会比较好检测和修复，但是 Native 内存泄漏就会比较难。</p><ol><li>Detecting and Fixing Memory Leaks - 内存泄漏检测和修复，是一个比较大的工程，可以参考 LeakCanary、Matrix 等开源工具</li><li>Context - 使用不当会造成该释放的对象没有释放造成内存泄漏</li><li>Native Memory Leaks</li></ol><h2 id="3rd-Party-Library"><a href="#3rd-Party-Library" class="headerlink" title="3rd Party Library"></a>3rd Party Library</h2><p>经典的第三方类库，可以大幅节约我们的开发时间</p><ol><li>Image Loading - Glide, Picasso</li><li>Dependency Injection - Dagger</li><li>Networking - Fast Android Networking Library, Retrofit</li><li>MultiThreading - RxJava, Coroutines</li></ol><h2 id="Data-Format"><a href="#Data-Format" class="headerlink" title="Data Format"></a>Data Format</h2><p>常见的一些数据保存流格式</p><ol><li>JSON — GSON</li><li>Flat Buffer</li><li>Protocol Buffer</li></ol><h2 id="Android-Jetpack"><a href="#Android-Jetpack" class="headerlink" title="Android Jetpack"></a>Android Jetpack</h2><p><a href="https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack%3Fhl%3Dzh-cn">Jetpack</a> 是 Google 推出的一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。</p><ol><li>Foundation Components — AppCompat, Android KTX, Multidex</li><li>Architecture Components — LiveData, ViewModel, DataBinding, Paging, Work Manager, Navigation</li><li>Behaviour Components - Download Manager, Media Playback, Notification, Permissions, Preference, Sharing, Slice</li><li>UI Component - Animation &amp; Transition, Android Auto, Emoji, Palette, Android TV, Android Wear</li></ol><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>传统的开发架构，没有绝对的哪个好哪个不好，只有哪个适合哪个不适合，下面三种你都应该知道并有一定的了解</p><ol><li>MVVM - MVVM 是 Model-View-ViewModel的简写。它本质上就是 MVC 的改进版。MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开</li><li>MVI ？</li><li>MVP - MVP 从更早的 MVC 框架演变过来，与 MVC 有一定的相似性：Controller/Presenter 负责逻辑的处理，Model 提供数据，View 负责显示</li></ol><h2 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing"></a>Unit Testing</h2><ol><li>Local Unit Testing</li><li>Instrumentation Testing</li></ol><h2 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h2><p>Firebase 国内很多开发者用不到，这里简单看一下即可（说不定哪天国内就可以用了呢）</p><ol><li>FCM</li><li>Crashlytics</li><li>Analytics</li><li>Remote Config</li><li>App Indexing</li><li>Dynamic Link</li></ol><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>安全方面接触毕竟多的应该是加密、解密、混淆等，毕竟用户数据安全大于一切，不重视这个欧盟会教你做人</p><ol><li>Encrypt / Decrypt</li><li>Proguard</li><li>R8</li></ol><h2 id="App-Release"><a href="#App-Release" class="headerlink" title="App Release"></a>App Release</h2><p>应用发布相关的知识，国内还得加上多渠道打包、插件化</p><ol><li>.keystore file</li><li>App Bundle</li><li>Playstore</li><li>多渠道打包</li><li>插件化</li></ol><h2 id="Keep-Learning-and-Improving"><a href="#Keep-Learning-and-Improving" class="headerlink" title="Keep Learning and Improving"></a>Keep Learning and Improving</h2><p>作为一个有进取心的 Android 开发者，拥有自己的技术栈和规划非常重要，技术栈确保你有足够的市场竞争力，从而形成护城河；技术规划则可以给你一个明确的学习目标。卸载抖音、微博、斗鱼、游戏吧，做好 2020 年的规划，<strong>Keep Learning and Improving</strong> ，共勉</p>]]></content>
      
      
      <categories>
          
          <category> Android学习路线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning Route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Project Structure</title>
      <link href="posts/64157/"/>
      <url>posts/64157/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习目标：熟悉各种项目结构，资源文件、Gradle文件。</p><p>Java/kotin/Flutter,XML,.gradle files</p></blockquote><h1 id="文件结构解析"><a href="#文件结构解析" class="headerlink" title="文件结构解析"></a>文件结构解析</h1><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/wmy1696/cdn/img/20200918114002.png" alt=""></p><ol><li>.gradle和.idea：AS自动生成的文件</li><li>app：项目中代码资源等内容</li><li>build：编译时自动生成的文件</li><li>gradle：包含了gradle wrapper的配置文件，使用gradle wrapper方式，不需提前将gradle下载好，根据本地缓存情况决定是否联网下载（AS默认开启），也可更改为离线模式：File–&gt;Settings–&gt;Build,Execution,Deloyment–&gt;Gradle</li><li>.gitignore：排除文件版本控制</li><li>build.gradle：项目全局gradle构建脚本</li><li>gradle.properties：全局gradle配置文件，配置相关属性</li><li>gradlew和gradlew.bat：命令行界面执行gradle命令，gradlew在Linux和Mac</li><li>xxx.iml：iml文件是标识这是一个IntelliJ IDEA项目</li><li>local.properties：指定本机SDK路径</li><li>setting.gradle：指定项目所有引入的模块，目前只有app模块</li></ol><h3 id="详解app目录"><a href="#详解app目录" class="headerlink" title="详解app目录"></a>详解app目录</h3><ol><li>build：编译时自动生成文件  </li><li>libs：第三方jar包</li><li>androiTest:Android test自动化测试用例 </li><li>Java:所有java代码放置地方，MainActivity.java </li><li>res：图片、布局、字符串等 </li><li>AndroidManifest.xml：项目配置文件，譬如四大组件的定义  </li><li>test：unit test自动化测试用例</li><li>app.iml：IntelliJ IDEA标识</li><li>build.gradle：app模块的gradle构建样本，项目构建相关配置</li><li>progurad-reles.pro：执行项目混淆规则</li></ol><h3 id="详解项目中的资源"><a href="#详解项目中的资源" class="headerlink" title="详解项目中的资源"></a>详解项目中的资源</h3><p>res目录下的项目资源：</p><ol><li>drawable：图片         </li><li>Mipmap:图标（不同后缀更好兼容设备）         </li><li>Vaules:字符串、样式、颜色等。</li></ol><h3 id="详解build-gradle文件"><a href="#详解build-gradle文件" class="headerlink" title="详解build.gradle文件"></a>详解build.gradle文件</h3><p><strong>最外层目录的build.gradle</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  ext.kotlin_version = '1.3.71'</span><br><span class="line">  //闭包声明了两个代码仓库，后面可以引用仓库的依赖库</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google() //google扩展依赖库</span><br><span class="line">    jcenter()//第三方开源库</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">  //使用classpath声明了两个插件</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    //Gradle不是专门为Android项目开发的，需要声明</span><br><span class="line">    //Gradle插件的目的是构建android项目，与AS版本一致</span><br><span class="line">    classpath 'com.android.tools.build:gradle:3.6.3'</span><br><span class="line">    //Kotlin插件</span><br><span class="line">    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">allprojects &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    jcenter()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>app目录的build.gradle</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: 'com.android.application'</span><br><span class="line">//应用程序模块，也可以设置为库模块(com.android.library)</span><br><span class="line"></span><br><span class="line">apply plugin: 'kotlin-android'</span><br><span class="line">apply plugin: 'kotlin-android-extensions'//kotlin模块和扩展功能</span><br><span class="line"></span><br><span class="line">//项目构建的各个属性</span><br><span class="line">android &#123;</span><br><span class="line">  compileSdkVersion 28  //指定项目编译版本</span><br><span class="line">  buildToolsVersion "29.0.3"  //Android10.0SDK编译</span><br><span class="line">  </span><br><span class="line">  //项目更多细节配置</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    applicationId "com.example.myapplication"//应用唯一标识符</span><br><span class="line">    minSdkVersion 21///项目最低兼容版本，最低兼容5.0</span><br><span class="line">    targetSdkVersion 28//目标版本，在该版本充分测试，启用新特性，9.0</span><br><span class="line">    versionCode 1 //项目版本号</span><br><span class="line">    versionName "1.0"//项目版本名</span><br><span class="line">    //启用Junit测试用例</span><br><span class="line">    testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //生成安装文件的相关配置</span><br><span class="line">  buildTypes &#123;</span><br><span class="line">  //一般一个release包（正式版安装文件配置），一个debug包（测试版安装文件配置）。</span><br><span class="line">    release &#123;</span><br><span class="line">      minifyEnabled false//是否对项目混淆</span><br><span class="line">      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), </span><br><span class="line">'proguard-rules.pro'</span><br><span class="line">      //选择混淆规则</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //指定项目所有依赖关系。</span><br><span class="line">    //本地依赖（jar包或者目录）、库依赖（项目中的库模块）和远程依赖（jcenter仓库开源项目）。</span><br><span class="line">    dependencies &#123;</span><br><span class="line">      //implementation fileTree本地依赖，libs目录底下的所有jar包  </span><br><span class="line">      implementation fileTree(dir: 'libs', include: ['*.jar'])</span><br><span class="line">      //implementation远程依赖声明，标准远程库格式，androidx.appcompat:为域名部分，appcompat为工程名，1.0.2是版本号</span><br><span class="line">      //Gradle构建时会检查本地是否有库缓存，没有会自动联网下载并添加到项目构建路径</span><br><span class="line">      implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"</span><br><span class="line">      implementation 'androidx.appcompat:appcompat:1.0.2'</span><br><span class="line">      implementation 'androidx.core:core-ktx:1.0.2'</span><br><span class="line">      implementation 'androidx.constraintlayout:constraintlayout:1.1.3'</span><br><span class="line">      //implementation project是库依赖，譬如一个库名叫help，可以声明为（implementation project('help')）</span><br><span class="line">      //声明测试用例库的</span><br><span class="line">      testImplementation 'junit:junit:4.12'</span><br><span class="line">      androidTestImplementation 'androidx.test.ext:junit:1.1.1'</span><br><span class="line">      androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android项目结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub图床</title>
      <link href="posts/47105/"/>
      <url>posts/47105/</url>
      
        <content type="html"><![CDATA[<h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p>因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 <code>Ctrl + C</code> 的方式一键搞定，为了解决这个问题，使用 <code>MarkDown + 图床</code> 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。<br>所谓图床，就是<strong>将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。</strong><code>MarkDown</code> 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。</p><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ol><li><p>新建 GitHub 仓库（cdn）</p></li><li><p>生成一个 Token (上传到github验证token)</p></li><li><p>配置 PicGo 并使用 jsdelivr 作为 CDN 加速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;wmy1696&#x2F;cdn&#x2F;img&#x2F;SC04C03.jpg &#x2F;&#x2F;格式</span><br></pre></td></tr></table></figure></li><li><p>使用 Imagine 进行图片压缩</p></li><li><p>上传图片到 PicGo 并使用图床</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图床 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道》笔记</title>
      <link href="posts/59528/"/>
      <url>posts/59528/</url>
      
        <content type="html"><![CDATA[<h1 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h1><ul><li><p>名副其实</p></li><li><p>避免误导</p></li><li><p>做出有意义的区分</p></li><li><p>使用读的出来的名称</p></li><li><p>使用可搜索的名称</p></li><li><p>避免使用编码（不要把类型或作用域编进名称）</p><ul><li>匈牙利语标记法</li></ul><ul><li>成员前缀</li><li>接口与实现</li></ul></li><li><p>避免思维映射（不要让人把名称翻译为他们熟知的名称）</p></li><li><p>类名（名词或名称短语）</p></li><li><p>方法名（动词或动词短语）</p></li><li><p>别扮可爱（宁可明确，不要好玩）</p></li><li><p>每个概念对应一个词</p></li><li><p>别用双关语</p></li><li><p>使用解决方案领域名称</p></li><li><p>使用源自所涉问题领域的名称</p></li><li><p>添加有意义的语境</p></li><li><p>不要添加没用的语境</p></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li><p>短小（20行封顶最佳）</p></li><li><p>只做一件事</p></li><li><p>每个函数一个抽象层级（向下规则）</p></li><li><p>switch语句（用于创建多态对象，隐藏在某个继承关系）</p></li><li><p>使用描述性的名称（别怕长名称、命名方式保存一致）</p></li><li><p>函数参数（理想是0）</p><ul><li>一元函数的普遍形式（问参数问题 or 操作参数）</li></ul><ul><li>标识参数（不要向函数传入布尔值）</li><li>二元函数（两个参数是否有关联–&gt;其中一个变为成员变量）</li><li>三元函数</li><li>参数对象（将参数封装成类）</li><li>参数列表（可变参数）</li></ul></li><li><p>无副作用（不要时序耦合）</p></li><li><ul><li>输出参数（避免使用，改为修改所属对象的状态）</li></ul></li><li><p>分隔指令与询问（函数要么回答什么事，要么做什么事）</p></li><li><p>使用异常代替返回错误码</p><ul><li>抽离Try/Catch代码块</li></ul><ul><li>错误处理就是一件事</li><li>Error.java依赖磁铁</li></ul></li><li><p>结构化编程（大函数中：每个函数中该只有一个return语句，循环中不能有break/continue,不能用goto语句。小函数是可以的）</p></li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li><p>注释不能美化的糟糕代码</p></li><li><p>用代码来阐述（推荐）</p></li><li><p>好注释</p><ul><li>法律信息</li></ul><ul><li>提供信息的注释</li><li>对意图的解释</li><li>阐释</li><li>警示</li><li>TODO注释（应该做还没有做）</li><li>放大</li><li>公共API中的Javadoc</li></ul></li><li><p>坏注释</p><ul><li>喃喃自语</li></ul><ul><li>多余的注释</li><li>误导性注释</li><li>循规式注释</li><li>日志式注释</li><li>废话注释</li><li>能用函数或变量时别用注释</li><li>位置标记</li><li>括号后面的注释</li><li>归属与签名（交给源代码控制系统）</li><li>注释掉的代码</li><li>HTML注释</li><li>非本地信息</li><li>信息过多</li><li>不明显的联系</li><li>函数头（取好名字而不是注释）</li><li>非公共代码中的Javadoc</li></ul></li></ul><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><ul><li><p>垂直格式</p><ul><li>向报纸学习</li></ul><ul><li><p>概念间垂直方向的区隔</p></li><li><p>垂直方向上的靠近</p></li><li><p>垂直距离</p><ul><li>变量声明</li></ul><ul><li>实体变量</li><li>相关函数</li><li>概念相关</li></ul></li><li><p>垂直顺序</p></li></ul></li><li><p>横向格式</p><ul><li>水平方向上的区隔与靠近</li></ul><ul><li>水平对齐</li><li>缩进</li><li>空范围</li></ul></li><li><p>团队规则</p></li></ul><h1 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h1><ul><li><p>数据抽象</p></li><li><p>数据、对象的反对称性</p></li><li><ul><li>对象隐藏数据，暴露操作</li><li>数据结构暴露数据，不提供操作</li></ul></li><li><p>得墨忒耳律</p><ul><li>模块不应了解它所操作对象的内部情况</li></ul><ul><li>方法不应调用任何函数返回的对象的方法</li><li>火车失事（避免）</li><li>混杂</li><li>隐藏结构</li></ul></li><li><p>数据传送对象</p><ul><li>只有公共变量、没有函数的类（数据传送对象–DTO）</li></ul><ul><li>应用：与数据库通信、解析套接字传递的消息</li></ul></li><li><p>Active Record</p><ul><li>特殊的DTO形式，拥有公共变量的数据结构</li></ul></li><li><p>小结</p><ul><li>对象暴露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时难以在既有对象中添加新行为。</li></ul><ul><li>数据结构暴露数据，没有明显的行为。便于向既有数据结构添加新行为，同时难以向既有函数添加新数据结构。</li></ul></li></ul><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ul><li>使用异常而非返回码</li><li>先写Try-Catch-Finally语句</li><li>使用不可控异常（可控异常违反开发/闭合原则）</li><li>给出异常发生的环境说明（stack trace）</li><li>依调用者需要定义异常类（将第三方API打包）</li><li>定义常规流程（特例模式）</li><li>别返回null值 </li><li>别传递null值</li><li>小结：将错误处理隔离看待，独立于主要逻辑之外</li></ul><h1 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h1><ul><li><p>使用第三方代码</p></li><li><p>浏览和学习边界</p><ul><li>通过编写测试</li></ul></li><li><p>学习log4j</p></li><li><p>学习性测试的好处不只是免费</p></li><li><p>使用尚不存在的代码</p><ul><li>Controller类、Adapter模式</li></ul></li><li><p>整洁的边界</p><ul><li>边界上的代码需要清晰的分割和定义了期望的测试</li></ul><ul><li>避免代码过多了解第三方代码中特定信息</li><li>第三方边界可以像对Map那样包装它们，也可以用ADAPTER模式转换为第三方提供放入接口</li></ul></li></ul><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul><li><p>TDD三定律</p></li><li><p>保存测试整洁</p></li><li><p>整洁的测试</p><ul><li>构造-操作-检验</li></ul><ul><li>面向特定领域的测试语言</li><li>双重标准</li></ul></li><li><p>每个测试一个断言</p><ul><li>每个测试一个概念</li></ul></li><li><p>F.I.R.S.T</p><ul><li>快速</li></ul><ul><li>独立</li><li>可重复</li><li>自足验证（测试应有布尔值输出）</li><li>及时</li></ul></li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul><li><p>类的组织</p></li><li><p>类应该短小</p><ul><li>单一权责原则（SRP）</li></ul><ul><li>内聚（一个类每个变量被每个方法使用）</li><li>保存内聚性会得到许多短小的类</li></ul></li><li><p>为了修改而组织</p><ul><li>隔离修改</li></ul><ul><li>依赖导致原则</li></ul></li></ul><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><ul><li><p>将系统的构造与使用分开</p><ul><li>分解main(main函数创建系统所需对象，再传递给应用程序)</li></ul><ul><li>抽象工厂模式（应用程序负责确定何时创建对象）</li><li>依赖注入</li></ul></li></ul><blockquote><p>依赖注入（DI）是 控制反转（IoC）是依赖管理中的一种应用手段。控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中。</p></blockquote><ul><li><p>扩容</p><ul><li>横贯式关注面（EBJ2架构）</li></ul><ul><li>AOP</li></ul></li></ul><blockquote><p>AOP(面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p></blockquote><blockquote><p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p></blockquote><ul><li><p>Java代理</p></li><li><p>纯Java AOP框架</p></li><li><p>AspectJ的方面</p></li><li><p>测试驱动的系统架构</p><ul><li>最佳的系统架构由模块化的关注面领域组成，每个关注面均用纯Java对象实现。不同领域之间用最不具有侵害性的方面或类方面工具整合起来。</li></ul></li><li><p>优化决策</p></li><li><p>明智使用添加了可论证价值的标准</p></li><li><p>系统需要领域特定语言</p></li></ul><h1 id="迭进"><a href="#迭进" class="headerlink" title="迭进"></a>迭进</h1><ul><li><p>通过迭进设计达到整洁的目的</p></li><li><p>简单设计规则1：运行所有测试</p></li><li><p>简单设计规则2~4：重构</p><ul><li>提升内聚性</li></ul><ul><li>降低耦合度</li><li>切分关注面</li><li>模块化系统关注面</li><li>缩小函数和类的尺寸</li><li>选用更好的名称</li></ul></li><li><p>不可重复</p></li><li><p>表达力</p><ul><li>选用好的名称</li></ul><ul><li>保持函数和类尺寸短小</li><li>采用标准命名法</li><li>编写良好的单元测试</li><li>尝试</li></ul></li><li><p>尽可能少的类和方法</p><ul><li>保持函数和类短小的同时，保持整个系统短小精悍</li></ul></li></ul><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><ul><li><p>为什么要并发</p><ul><li>解耦目的与时机能明显的改进应用程序的吞吐量和结构</li></ul></li><li><p>并发防御原则</p><ul><li>单一权责原则（分离并发相关代码与其他代码）</li></ul><ul><li>限制数据作用域</li><li>使用数据副本</li><li>线程应尽可能地独立</li></ul></li><li><p>了解Java库</p><ul><li>线程安全集群</li></ul></li><li><p>了解执行模型</p><ul><li>生产者-消费者模型</li></ul><ul><li>读者-作者模型</li><li>宴席哲学家</li></ul></li><li><p>警惕同步方法之间地依赖</p><ul><li>避免使用一个共享对象地多个方法</li></ul></li><li><p>保持同步区域微小</p></li><li><p>很难编写正确地关闭代码</p><ul><li>尽早考虑关闭问题</li></ul></li><li><p>测试线程代码</p><ul><li>将伪失败看作可能地线程问题</li></ul><ul><li><p>先使非线程代码可工作</p></li><li><p>编写可插拔地线程代码（多个配置环境下）</p></li><li><p>编写可调整地线程代码（线程数量可调整）</p></li><li><p>运行于多处理器数量的线程</p></li><li><p>在不同平台上运行</p></li><li><p>装置试错代码</p><ul><li>硬编码（手工插入wait、sleep、yield、priority）</li></ul><ul><li>自动化（使用Aspect-Oriented Framework、CGLIB、ASM等工具）</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《代码整洁之道》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions</title>
      <link href="posts/58909/"/>
      <url>posts/58909/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h1><h2 id="GitHub-Actions-是什么？"><a href="#GitHub-Actions-是什么？" class="headerlink" title="GitHub Actions 是什么？"></a>GitHub Actions 是什么？</h2><p>持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p><p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p><p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p><p>GitHub 做了一个<a href="https://github.com/marketplace?type=actions" target="_blank" rel="noopener">官方市场</a>，可以搜索到他人提交的 actions。另外，还有一个 <a href="https://github.com/sdras/awesome-actions" target="_blank" rel="noopener">awesome actions</a> 的仓库，也可以找到不少 action。</p><p>上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用<code>userName/repoName</code>的语法引用 action。比如，<code>actions/setup-node</code>就表示<code>github.com/actions/setup-node</code>这个<a href="https://github.com/actions/setup-node" target="_blank" rel="noopener">仓库</a>，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 <a href="https://github.com/actions" target="_blank" rel="noopener">github.com/actions</a> 里面。</p><p>既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见<a href="https://help.github.com/en/articles/about-actions#versioning-your-action" target="_blank" rel="noopener">官方文档</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">actions&#x2F;setup-node@74bc508 # 指向一个 commit</span><br><span class="line">actions&#x2F;setup-node@v1.0    # 指向一个标签</span><br><span class="line">actions&#x2F;setup-node@master  # 指向一个分支</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>GitHub Actions 有一些自己的术语。</p><p>（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p><p>（2）<strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p><p>（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p><p>（4）<strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p><h2 id="workflow-文件"><a href="#workflow-文件" class="headerlink" title="workflow 文件"></a>workflow 文件</h2><p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的<code>.github/workflows</code>目录。</p><p>workflow 文件采用 <a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML 格式</a>，文件名可以任意取，但是后缀名统一为<code>.yml</code>，比如<code>foo.yml</code>。一个库可以有多个 workflow 文件。GitHub 只要发现<code>.github/workflows</code>目录里面有<code>.yml</code>文件，就会自动运行该文件。</p><p>workflow 文件的配置字段非常多，详见<a href="https://help.github.com/en/articles/workflow-syntax-for-github-actions" target="_blank" rel="noopener">官方文档</a>。下面是一些基本字段。</p><p><strong>（1）<code>name</code></strong></p><p><code>name</code>字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: GitHub Actions Demo</span><br></pre></td></tr></table></figure><p><strong>（2）<code>on</code></strong></p><p><code>on</code>字段指定触发 workflow 的条件，通常是某些事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on: push</span><br></pre></td></tr></table></figure><p>上面代码指定，<code>push</code>事件触发 workflow。</p><p><code>on</code>字段也可以是事件的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on: [push, pull_request]</span><br></pre></td></tr></table></figure><p>代码指定，<code>push</code>事件或<code>pull_request</code>事件都可以触发 workflow。</p><p>完整的事件列表，请查看<a href="https://help.github.com/en/articles/events-that-trigger-workflows" target="_blank" rel="noopener">官方文档</a>。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p><p><strong>（3）<code>on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;</code></strong></p><p>指定触发事件时，可以限定分支或标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:    </span><br><span class="line">      - master</span><br></pre></td></tr></table></figure><p>上面代码指定，只有<code>master</code>分支发生<code>push</code>事件时，才会触发 workflow。</p><p><strong>（4）<code>jobs.&lt;job_id&gt;.name</code></strong></p><p>workflow 文件的主体是<code>jobs</code>字段，表示要执行的一项或多项任务。</p><p><code>jobs</code>字段里面，需要写出每一项任务的<code>job_id</code>，具体名称自定义。<code>job_id</code>里面的<code>name</code>字段是任务的说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  my_first_job:</span><br><span class="line">    name: My first job</span><br><span class="line">  my_second_job:</span><br><span class="line">    name: My second job</span><br></pre></td></tr></table></figure><p>上面代码的<code>jobs</code>字段包含两项任务，<code>job_id</code>分别是<code>my_first_job</code>和<code>my_second_job</code>。</p><p><strong>（5）<code>jobs.&lt;job_id&gt;.needs</code></strong></p><p><code>needs</code>字段指定当前任务的依赖关系，即运行顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">  job2:</span><br><span class="line">    needs: job1</span><br><span class="line">  job3:</span><br><span class="line">    needs: [job1, job2]</span><br></pre></td></tr></table></figure><p>上面代码中，<code>job1</code>必须先于<code>job2</code>完成，而<code>job3</code>等待<code>job1</code>和<code>job2</code>的完成才能运行。因此，这个 workflow 的运行顺序依次为：<code>job1</code>、<code>job2</code>、<code>job3</code>。</p><p><strong>（6）<code>jobs.&lt;job_id&gt;.runs-on</code></strong></p><p><code>runs-on</code>字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p><ul><li><code>ubuntu-latest</code>，<code>ubuntu-18.04</code>或<code>ubuntu-16.04</code></li><li><code>windows-latest</code>，<code>windows-2019</code>或<code>windows-2016</code></li><li><code>macOS-latest</code>或<code>macOS-10.14</code></li></ul><p>下面代码指定虚拟机环境为<code>ubuntu-18.04</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runs-on: ubuntu-18.04</span><br></pre></td></tr></table></figure><p><strong>（7）<code>jobs.&lt;job_id&gt;.steps</code></strong></p><p><code>steps</code>字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p><ul><li><code>jobs.&lt;job_id&gt;.steps.name</code>：步骤名称。</li><li><code>jobs.&lt;job_id&gt;.steps.run</code>：该步骤运行的命令或者 action。</li><li><code>jobs.&lt;job_id&gt;.steps.env</code>：该步骤所需的环境变量。</li></ul><p>下面是一个完整的 workflow 文件的范例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">name: Greeting from Mona</span><br><span class="line">on: push</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">my-job:</span><br><span class="line"> name: My Job</span><br><span class="line"> runs-on: ubuntu-latest</span><br><span class="line"> steps:</span><br><span class="line">    - name: Print a greeting</span><br><span class="line">      env:</span><br><span class="line">        MY_VAR: Hi there! My name is</span><br><span class="line">        FIRST_NAME: Mona</span><br><span class="line">        MIDDLE_NAME: The</span><br><span class="line">        LAST_NAME: Octocat</span><br><span class="line">      run: |</span><br><span class="line">        echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.</span><br></pre></td></tr></table></figure><p>上面代码中，<code>steps</code>字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub搭建博客</title>
      <link href="posts/25464/"/>
      <url>posts/25464/</url>
      
        <content type="html"><![CDATA[<h1 id="GitHub搭建博客"><a href="#GitHub搭建博客" class="headerlink" title="GitHub搭建博客"></a>GitHub搭建博客</h1><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><ul><li>GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件（可选），通过构建过程运行文件，然后发布网站。 您可以在 <a href="https://github.com/collections/github-pages-examples" target="_blank" rel="noopener">GitHub Pages 示例集合</a>中查看 GitHub Pages 站点的示例。</li><li>可以在 GitHub 的 <code>github.io</code> 域或自己的自定义域上托管站点，要发布用户站点，必须创建名为 <code>&lt;user&gt;.github.io</code> 的用户帐户所拥有的仓库。</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。可以进入<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a>进行详细查看。</p><h3 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h3><ul><li><p>安装Git</p><p>windows：到git官网上下载,<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>linux：只需要一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li><li><p>安装Node.js</p><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a>选择LTS版本就行了。</p><p>linux：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装完后，打开命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v  &#x2F;&#x2F;检查一下有没有安装成功</span><br></pre></td></tr></table></figure></li><li><p>安装Hexo</p><p>先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>Hexo操作</p><p>可以下载好开源的博客模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog  &#x2F;&#x2F;初始化</span><br><span class="line">cd myblog &#x2F;&#x2F;进入这个myblog文件夹</span><br><span class="line">npm install &#x2F;&#x2F;安装依赖</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li><p>node_modules: 依赖包</p></li><li><p>public：存放生成的页面</p></li><li><p>scaffolds：生成文章的一些模板</p></li><li><p>source：用来存放你的文章，在_psot文件夹下写文章</p></li><li><p>themes：主题</p></li><li><p>_config.yml: 博客的配置文件</p><p>  hexo clean //清除之前的生成<br>  hexo g   //生成<br>  hexo server //启动本地服务器<br>在浏览器输入localhost:4000就可以看到你生成的博客了。</p></li></ul></li><li><p>将hexo部署到GitHub</p><p>打开站点配置文件 <code>_config.yml</code>，修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo:</span><br><span class="line">        git@github.com:wmy1696&#x2F;wmy1696.github.io.git &#x2F;&#x2F;写ssh格式，不然自动部署有bug</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo generate  &#x2F;&#x2F;生成静态文章，可以用 &#96;hexo g&#96;缩写</span><br><span class="line">hexo deploy  &#x2F;&#x2F;部署文章</span><br></pre></td></tr></table></figure></li></ul><h2 id="hexo主题模板"><a href="#hexo主题模板" class="headerlink" title="hexo主题模板"></a>hexo主题模板</h2><p>记录一下搭建过程中参考的大神模板：</p><p><a href="https://demo.jerryc.me/" target="_blank" rel="noopener">https://demo.jerryc.me/</a></p><p><a href="https://sitoi.cn/" target="_blank" rel="noopener">https://sitoi.cn/</a></p><p><a href="https://yangchaoyi.vip/" target="_blank" rel="noopener">https://yangchaoyi.vip/</a></p><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><ul><li>编写文章，推送到 <code>GitHub</code> 即可实现自动部署</li><li>利用 <code>GitHub</code> 的私有仓库将博客源码直接保存在 <code>GitHub</code> 上</li></ul><p>首先将你自己的<code>Hexo</code> 博客源码的仓库，push到 <code>GitHub</code> 上。</p><h3 id="为需要部署的平台添加密钥"><a href="#为需要部署的平台添加密钥" class="headerlink" title="为需要部署的平台添加密钥"></a>为需要部署的平台添加密钥</h3><p>你电脑在 <code>~/.ssh</code> 目录下一定有以下三个文件：</p><ul><li><code>id_rsa</code>：私钥</li><li><code>id_rsa.pub</code>：公钥</li><li><code>known_hosts</code>：记录对所有用户都可信赖的远程主机的公钥</li><li>将 <code>id_rsa.pub</code>（公钥）添加到GitHub</li></ul><p>ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。</p><h3 id="修改-config-yml-中的-deploy-配置"><a href="#修改-config-yml-中的-deploy-配置" class="headerlink" title="修改 _config.yml 中的 deploy 配置"></a>修改 <code>_config.yml</code> 中的 <code>deploy</code> 配置</h3><p>请使用 <code>ssh</code> (即以 <code>git@</code> 开头的 <code>clone</code> 链接) 的连接方式，根据直接的实际地址填写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      github: git@github.com:Sitoi&#x2F;Sitoi.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><h3 id="在-GitHub-上设置-Secrets"><a href="#在-GitHub-上设置-Secrets" class="headerlink" title="在 GitHub 上设置 Secrets"></a>在 GitHub 上设置 <code>Secrets</code></h3><ol><li>进入到你在 <code>GitHub</code> 上面的源码仓库</li><li>点击右上角的 <code>Settings</code>,点击左侧的 <code>Secrets</code></li><li>在 <code>Name</code> 中输入 <code>HEXO_DEPLOY_PRI</code>，在 <code>Value</code> 中填入 <code>id_rsa</code>（私钥）的全部内容</li></ol><h3 id="创建-GitHub-Action"><a href="#创建-GitHub-Action" class="headerlink" title="创建 GitHub Action"></a>创建 GitHub Action</h3><p>修改 <code>main.yaml</code> 的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">name: Hexo CI</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master  &#x2F;&#x2F;master分支push时触发</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  butterfly-build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [10.x]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions&#x2F;checkout@v1</span><br><span class="line">      - name: Use Node.js 10.x</span><br><span class="line">        uses: actions&#x2F;setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#39;10.x&#39;</span><br><span class="line">          </span><br><span class="line">      - name: env prepare</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PRI: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class="line">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">          chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">          ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts &#x2F;&#x2F;收集公钥</span><br><span class="line">          git config --global user.name &#39;sitoi&#39;</span><br><span class="line">          git config --global user.email &#39;133397418@qq.com&#39;</span><br><span class="line">          npm i</span><br><span class="line">          npm i hexo@4.1.1 -g</span><br><span class="line">          </span><br><span class="line">      - name: gen</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean</span><br><span class="line">          hexo generate</span><br><span class="line">          hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio搭配Git</title>
      <link href="posts/42790/"/>
      <url>posts/42790/</url>
      
        <content type="html"><![CDATA[<h1 id="AS搭配git"><a href="#AS搭配git" class="headerlink" title="AS搭配git"></a>AS搭配git</h1><h2 id="安装配置Git"><a href="#安装配置Git" class="headerlink" title="安装配置Git"></a>安装配置Git</h2><p>下载地址：<a href="http://git-scm.com/download/" target="_blank" rel="noopener">http://git-scm.com/download/</a></p><p>安装完成后，在开始菜单里找到“Git”–&gt;“Git Bash”打开即可。</p><h3 id="配置信息："><a href="#配置信息：" class="headerlink" title="配置信息："></a>配置信息：</h3><p>输入你的用户名与邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>命令中的 –global 参数表示你这台机器上所有的Git仓库都会使用这个配置。</p><h3 id="AS中配置Git"><a href="#AS中配置Git" class="headerlink" title="AS中配置Git"></a>AS中配置Git</h3><p>在Android Studio中点击Settings–&gt;Version Control –&gt; Git，然后在Path To Git executable上输入你刚刚安装Git的位置，最后点击Test按钮出现Git executed successfully说明配置成功，</p><h3 id="AS搭配GitHub"><a href="#AS搭配GitHub" class="headerlink" title="AS搭配GitHub"></a>AS搭配GitHub</h3><p>检查是否有 SSH Keys</p><p>在Git Bash 客户端，输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ls</span><br><span class="line">--&gt;  id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><p>创建一个 SSH Keys</p><p>在Git Bash 客户端，输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure><p>第一个Enter表示Keys存储的位置，默认按回车键即可。第二个和第三个Enter表示Push文件的时候要输入的密码，不需要密码就默认按回车键即可</p><h3 id="GitHub配置SSH-Keys"><a href="#GitHub配置SSH-Keys" class="headerlink" title="GitHub配置SSH Keys"></a>GitHub配置SSH Keys</h3><p>进入存储 id_rsa.pub 的文件夹拷贝该文件中的内容，然后登录你的GitHub账号，点击网页右上角的头像–&gt;Settings，点击左边菜单栏的 SSH Keys 进入页面添加 SSH key。</p><p>创建项目</p><p>在GitHUb网站点击导航条上的 “+” 即可进入创建项目的页面，然后根据提示填写相应信息</p><p>将项目上传到GitHub</p><h3 id="配置忽略文件"><a href="#配置忽略文件" class="headerlink" title="配置忽略文件:"></a><strong>配置忽略文件:</strong></h3><p>Android Studio创建项目后会自动生成.gitignore文件，这个文件可以用来忽略那些不用加入到仓库的文件。</p><p>一般情况下我们只需要将项目根目录下的/.idea/workspace.xml与/.idea/libraries改成.idea即可，其他没有特殊要求就用默认的。</p><h3 id="初始化本地Git仓库"><a href="#初始化本地Git仓库" class="headerlink" title="初始化本地Git仓库:"></a><strong>初始化本地Git仓库:</strong></h3><p>点击Android Studio顶部菜单栏上的VCS–&gt;Import into Version Control–&gt;Create Git Repository,然后选择需要初始化的项目根目录。初始化之后发现文件名由原来的白色变成了红色，这表示文件已经被git跟踪了，但是并没有添加到仓库中。</p><h3 id="将本地Git仓库已与远程仓库进行关联："><a href="#将本地Git仓库已与远程仓库进行关联：" class="headerlink" title="将本地Git仓库已与远程仓库进行关联："></a><strong>将本地Git仓库已与远程仓库进行关联：</strong></h3><p>打开项目文件夹，在该文件夹中打开Git Bash。输入如下命令后就代表本地Git仓库已与远程仓库进行关联了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitlab.com:wildma&#x2F;WildmaGit.git</span><br></pre></td></tr></table></figure><p>其中 <a href="mailto:git@gitlab.com">git@gitlab.com</a>:wildma/WildmaGit.git 为我们项目的远程地址，可以到我们前面创建项目中复制</p><h3 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件:"></a><strong>添加文件:</strong></h3><p>选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Add…</p><p>添加文件后发现文件名由原来的红色变成了绿色，说明已经将文件添加进仓库了。</p><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件:"></a><strong>提交文件:</strong></h3><p>每次提交前需要先更新项目，原因是如果是多人合作的项目，需要先将远程仓库中他人提交的最新代码更新到本地仓库。 VSC–&gt;Update Project</p><p>然后选中Merge，点击OK，如果本地代码与远程代码有冲突就会弹出冲突提示，根据需求Merge即可</p><p>Update后就可以提交文件了，选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Commit Directory…</p><p>然后会弹出提交框，可以选择你要提交的文件和填写提交信息，</p><p>提交文件后发现文件名由原来的绿色又变成了最开始的白色，说明已经将文件提交上仓库了。</p><h3 id="将提交的文件推送到远程仓库："><a href="#将提交的文件推送到远程仓库：" class="headerlink" title="将提交的文件推送到远程仓库："></a><strong>将提交的文件推送到远程仓库：</strong></h3><p>选中项目的根目录，点击Android Studio顶部菜单栏上的VCS–&gt;Git–&gt;Push…</p><h2 id="Git指令"><a href="#Git指令" class="headerlink" title="Git指令"></a>Git指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# DatabaseTest&quot; &gt;&gt; README.md  &#x2F;&#x2F;把这个字符写入文件</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M master  &#x2F;&#x2F;重命名</span><br><span class="line">git remote add origin git@github.com:wmy1696&#x2F;DatabaseTest.git &#x2F;&#x2F;ssh形式不用输密码</span><br><span class="line">git push -u origin master  &#x2F;&#x2F;将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status  &#x2F;&#x2F;查看修改文件</span><br><span class="line">git diff  &#x2F;&#x2F;查看具体修改内容</span><br><span class="line">git checkout app&#x2F;src&#x2F;...&#x2F;MainActivity.java  &#x2F;&#x2F;撤销未提交的修改,没有add</span><br><span class="line">git reset HEAD app&#x2F;...&#x2F;MainActivity.java  &#x2F;&#x2F;取消add的文件</span><br><span class="line">git log  &#x2F;&#x2F;查看提交记录</span><br><span class="line">git log 165c2e434e006518e8724b9b72ffaabcdaf8d2ca -1 -p</span><br><span class="line">&#x2F;&#x2F; -1表示看其中一条记录，-p看具体修改内容</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android Studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio插件</title>
      <link href="posts/50612/"/>
      <url>posts/50612/</url>
      
        <content type="html"><![CDATA[<h1 id="AS插件"><a href="#AS插件" class="headerlink" title="AS插件"></a>AS插件</h1><p><strong>插件的安装:</strong></p><p>File → Settings → Plugins → 插件名</p><h2 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h2><p>将 Json 字符串快速转成 JavaBean 对象，免去我们根据 Json 字符串手写对应 Java Bean 的过程.</p><p>Tips: 可以使用快捷键 alt + s (windows) / option + s (mac)</p><h2 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h2><p>快捷创建实例化控件,配合 butterknife 实现注解，不用再手动实现 findViewById 了。</p><ul><li>依赖：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.jakewharton:butterknife:10.1.0&#39;</span><br><span class="line">annotationProcessor &#39;com.jakewharton:butterknife-compiler:10.1.0&#39;</span><br><span class="line">compileOptions &#123;</span><br><span class="line">  sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">  targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setContentView资源文件后使用alt+insert选择butterknife injections就可以快捷注解了</p><h2 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h2><p>在右边实现代码预览，类似于 sublime ，快速定位。</p><h2 id="持续更新……"><a href="#持续更新……" class="headerlink" title="持续更新……"></a>持续更新……</h2>]]></content>
      
      
      <categories>
          
          <category> Android Studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> 常用插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio快捷键</title>
      <link href="posts/859/"/>
      <url>posts/859/</url>
      
        <content type="html"><![CDATA[<h1 id="AS的快捷键"><a href="#AS的快捷键" class="headerlink" title="AS的快捷键"></a>AS的快捷键</h1><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.F7 --&gt; 跳入</span><br><span class="line">2.Ctrl+Shift+F7 --&gt;强制跳入</span><br><span class="line">3.F8 --&gt;单步调试</span><br><span class="line">4.Ctrl+Shift+F8 --&gt;跳出</span><br><span class="line">5.F9 --&gt;跳转到下一个断点处</span><br><span class="line">6.Ctrl+Alt+F8 --&gt;查看当前选择的（变量、表达式、函数）值</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.Ctrl+D --&gt;复制当前行</span><br><span class="line">2.Ctrl+Y --&gt; 删除当前行</span><br><span class="line">3.Alt+Insert --&gt;生成构造器&#x2F;Getter&#x2F;Setter&#x2F;构造函数等--Alt+Fn+F12</span><br><span class="line">4.Ctrl+Alt+V --&gt;可以引入变量。例如把括号内的SQL赋成一个变量</span><br><span class="line">5.Ctrl+Alt+T --&gt;可以把代码包在一块内，例如try&#x2F;catch，if语句等</span><br><span class="line">6.Ctrl+Alt+Space --&gt;类名自动完成，自动生成可选变量名，类似于Elipse的（Alt+&#x2F;）快捷键功能</span><br><span class="line">7.Ctrl+W --&gt;扩展选择范围，选择单词继而语句继而函数</span><br><span class="line">8.Ctrl+Shift+W --&gt;缩小选择选择范围，选择函数继而语句继而单词</span><br><span class="line">9.Shift+F6 --&gt; 重命名</span><br><span class="line">10.Ctrl+O --&gt;重写父类方法</span><br><span class="line">11.Ctrl+Alt+L --&gt;格式化代码（配合Ctrl+A,谁用谁知道，一般人我不告诉他）</span><br><span class="line">12.Ctrl+Z --&gt;撤销一次操作</span><br><span class="line">12.Ctrl+Shit+Z --&gt;前进一次操作</span><br><span class="line">13.Ctrl+A --&gt;全选</span><br><span class="line">13.Ctrl+S --&gt;保存</span><br><span class="line">14.Ctrl+Alt+M --&gt;提取方法</span><br></pre></td></tr></table></figure><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Alt+Shift+↑ --&gt;当前行上移一行</span><br><span class="line">2.Alt+Shift+↓ --&gt;当前行下移一行</span><br><span class="line">3.Ctrl+Alt+ ← --&gt; 回退到上一个跳转点</span><br><span class="line">4.Ctrl+Alt+ → --&gt; 前进到下一个跳转点</span><br><span class="line">5.Ctrl+[ --&gt; 跳到当前代码块花括号的开头处</span><br><span class="line">6.Ctrl+] --&gt; 跳到当前代码块花括号的结尾处</span><br><span class="line">7.Alt+Up and Alt+Down --&gt;可在方法间快速移动</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Ctrl+Alt+H --&gt; 查找当前选择资源在工程内的所有调用位置</span><br><span class="line">2.Ctrl+F12 --&gt;显示当前文件的结构</span><br><span class="line">3.Ctrl+Q --&gt;查看当前方法的声明（在AS中开启悬浮提示比这个快捷键要实用,Setting-&gt;Editor-&gt;General-&gt;show quick doc on mouse Delay(勾上)）</span><br><span class="line">4.Ctrl+P --&gt;显示参数信息</span><br><span class="line">5.按两次Shift --&gt;工作空间内全局搜索文件</span><br><span class="line">6.Ctrl+F7 --&gt;可以查询当前元素在当前文件中的引用，然后按F3可以选择</span><br></pre></td></tr></table></figure><h2 id="不常用快捷键"><a href="#不常用快捷键" class="headerlink" title="不常用快捷键"></a>不常用快捷键</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.在一些地方按Alt+Enter可以得到一些Intention Action，例如将”&#x3D;&#x3D;”改为”equals()”</span><br><span class="line">2.Ctrl+Shift+Alt+N可以快速打开符号</span><br><span class="line">3.Ctrl+Shift+Space在很多时候都能够给出Smart提示</span><br><span class="line">4.Alt+F3可以快速寻找</span><br><span class="line">5.Ctrl+&#x2F;和Ctrl+Shift+&#x2F;可以注释代码</span><br><span class="line">6.Ctrl+Alt+B可以跳转到抽象方法的实现</span><br><span class="line">7.Ctrl+O可以选择父类的方法进行重写</span><br><span class="line">8.Ctrl+Q可以看JavaDoc</span><br><span class="line">9.快速打开类&#x2F;文件&#x2F;符号时，可以使用通配符，也可以使用缩写</span><br><span class="line">10.Live Templates! Ctrl+J</span><br><span class="line">11.Ctrl+Shift+F7可以高亮当前元素在当前文件中的使用</span><br><span class="line">12.Ctrl+Alt+Up &#x2F;Ctrl+Alt+Down可以快速跳转搜索结果</span><br><span class="line">13.Ctrl+Shift+J可以整合两行</span><br><span class="line">14.Ctrl+E --&gt;可以显示最近编辑的文件列表</span><br><span class="line">15.Ctrl+Shift+Backspace --&gt;可以跳转到上次编辑的地方</span><br><span class="line">16.Ctrl+N --&gt;可以快速打开类</span><br><span class="line">17.Ctrl+Shift+N --&gt;可以快速打开文件</span><br><span class="line">18.Alt+F1 --&gt;可以将正在编辑的元素在各个面板中定位</span><br><span class="line">19.Ctrl+Shift+Insert --&gt;可以选择剪贴板内容并插入</span><br><span class="line">20.Shift+Click --&gt;关闭文件（有点多余，直接按文件右上角的×就可以关闭）</span><br><span class="line">21.Ctrl+Alt+F--&gt;局部变量提取成为全局变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android Studio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git干货</title>
      <link href="posts/44799/"/>
      <url>posts/44799/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">RUNOOB</a></p><p><a href="http://git-scm.com/docs" target="_blank" rel="noopener">Git指令大全</a></p><p><a href="https://learngitbranching.js.org/?locale=zh_CN" target="_blank" rel="noopener">Learn Git Branching</a></p></blockquote><h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。<strong>每一个级别的配置都会覆盖上层的相同配置</strong>，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:/Documents and Settings/$USER。</p><p>此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2><p>要检查已有的配置信息，可以使用 git config –list 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name</span><br></pre></td></tr></table></figure><h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p>一般工作流程如下：</p><ol><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ol><h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><h2 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init &#x2F;&#x2F;初始化仓库</span><br><span class="line">git clone ssh地址 &#x2F;&#x2F;拷贝远程仓库</span><br></pre></td></tr></table></figure><h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .  &#x2F;&#x2F;添加文件到暂存区</span><br><span class="line">git status [-s]&#x2F;&#x2F;查看在你上次提交之后是否有对文件进行再次修改,-s输出短结果</span><br><span class="line">git diff [file] &#x2F;&#x2F;比较文件的不同，即暂存区和工作区的差异。</span><br><span class="line">git commit -m [message]</span><br><span class="line">git commit -a &#x2F;&#x2F;不经过暂存区</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^            # 回退所有内容到上一个版本  </span><br><span class="line">$ git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  </span><br><span class="line">$ git  reset  052e           # 回退到指定版本</span><br><span class="line">#相当于把add进暂存区的文件退回了，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;  #删除暂存区和工作区文件</span><br><span class="line">git rm -f runoob.txt &#x2F;&#x2F;删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。</span><br><span class="line">git rm --cached &lt;file&gt;  &#x2F;&#x2F;想把文件从暂存区域移除，但仍然希望保留在当前工作目录中</span><br><span class="line">git mv [file] [newfile] &#x2F;&#x2F;移动或重命名一个文件、目录或软连接。</span><br></pre></td></tr></table></figure><h2 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log &#x2F;&#x2F; 查看历史提交记录。</span><br><span class="line">git log --oneline  &#x2F;&#x2F;历史记录简洁版本</span><br><span class="line">git log --reverse  &#x2F;&#x2F;逆向</span><br><span class="line">git blame &lt;file&gt;   &#x2F;&#x2F;以列表形式查看指定文件的历史修改记录。</span><br></pre></td></tr></table></figure><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v  &#x2F;&#x2F;显示所有远程仓库</span><br><span class="line">git remote add [shortname] [url]  &#x2F;&#x2F;添加远程仓库</span><br><span class="line">git remote rm name  # 删除远程仓库</span><br><span class="line">git remote rename old_name new_name  # 修改仓库名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master &#x2F;&#x2F;将远程版本库修改同步到本地</span><br><span class="line">#同步下来的代码不会合并到任何分支，存放在origin&#x2F;master分支上</span><br><span class="line">git diff origin&#x2F;master  &#x2F;&#x2F;查看修改内容</span><br><span class="line">git merge origin&#x2F;master</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; </span><br><span class="line">&#x2F;&#x2F;git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。：</span><br><span class="line">git pull origin master:brantest  </span><br><span class="line">&#x2F;&#x2F;将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;&#x2F;&#x2F;从将本地的分支版本上传到远程并合并</span><br><span class="line">&#x2F;&#x2F;如果本地分支名与远程分支名相同，则可以省略冒号</span><br><span class="line">git push --force origin master</span><br><span class="line">&#x2F;&#x2F;如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数</span><br></pre></td></tr></table></figure><h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git branch &#x2F;&#x2F;列出分支</span><br><span class="line">git branch (branchname) &#x2F;&#x2F;创建分支</span><br><span class="line">git checkout (branchname) &#x2F;&#x2F;切换分支</span><br><span class="line">git checkout -b (branchname) &#x2F;&#x2F;创建新分支并立即切换到该分支下</span><br><span class="line">git branch -d (branchname)  &#x2F;&#x2F;删除分支</span><br><span class="line">git merge otherbranch &#x2F;&#x2F;将任何分支合并到当前分支</span><br><span class="line">git diff &#x2F;&#x2F;查看合并冲突，手动改</span><br><span class="line">&#x2F;&#x2F;合并冲突进入一个(master|MERGING)状态，在此打开冲突文件，会显示冲突的部分，修改后add commit,master分支融合成功内容改变，注意此时otherbranch的内容是不变的</span><br><span class="line">&#x2F;&#x2F;合并的分支产生了一个新的提交节点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase master&#x2F;&#x2F;合并分支, bugFix提交记录，“复制”它们，然后在master逐个的放下去。</span><br><span class="line">git rebase master bugFix</span><br></pre></td></tr></table></figure><p>Rebase 的优势就是可以创造更线性的提交历史,<strong>需要跟新master</strong></p><h1 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h1><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是<strong>指向你正在其基础上进行工作的提交记录</strong>。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p><p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p><p>HEAD -&gt; master -&gt; C1   HEAD 指向 master， master 指向 C1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout C1  &#x2F;&#x2F;HEAD -&gt; C1,通过哈希值指定提交记录</span><br></pre></td></tr></table></figure><h2 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h2><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，用 <code>git log</code> 来查看提交记录的哈希值。</p><p>并且哈希值在真实的 Git 世界中也会更长（基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够<strong>唯一标识提交记录的前几个字符</strong>即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p><p>通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。</p><p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p><p>相对引用两个简单的用法：</p><ol><li><p>使用 <code>^</code> 向上移动 1 个提交记录</p></li><li><p>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></p></li></ol><p>操作符 (^)：把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix^</span><br></pre></td></tr></table></figure><h2 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h2><p>使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -f master HEAD~3 &#x2F;&#x2F;将 master 分支强制指向 HEAD 的第 3 级父提交</span><br><span class="line">git branch -f master C6 &#x2F;&#x2F;将master强制指向C6</span><br></pre></td></tr></table></figure><h2 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h2><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^  &#x2F;&#x2F;向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</span><br></pre></td></tr></table></figure><p><code>git reset</code> 这种“改写历史”的方法对大家一起使用的远程分支是无效的.为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><p>在我们要撤销的提交记录后面多了一个新提交,这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code>是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h2 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h2><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;提交号&gt;</span><br><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure><h2 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h2><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你<strong>不清楚你想要的提交记录的哈希值</strong>呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p><p>当 rebase UI界面打开时, 你能做3件事:</p><ol><li>调整提交记录的顺序（通过鼠标拖放来完成）</li><li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li><li>合并提交。 它允许你把多个提交记录合并成一个。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>Git 严格按照你在对话框中指定的方式<strong>进行了复制</strong>。</p><h2 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h2><p>把 <code>bugFix</code> 分支里的工作合并回 <code>master</code> 分支。你可以选择通过 fast-forward 快速合并到 <code>master</code> 分支上，但这样的话 <code>master</code> 分支就会包含一些调试语句了。</p><p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p><ol><li><code>git rebase -i</code></li><li><code>git cherry-pick</code></li></ol><p>来达到目的。</p><h2 id="提交技巧"><a href="#提交技巧" class="headerlink" title="提交技巧"></a>提交技巧</h2><p>技巧一：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，提交了一次。</p><p>此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>可以通过下面的方法来克服困难：</p><ol><li><p>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</p></li><li><p>然后用 <code>git commit --amend</code> 来进行一些小修改（git commit –amend既可以对上次提交的内容进行修改，也可以修改提交说明）</p></li><li><p>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</p></li><li><p>最后我们把 master 移到修改的最前端</p></li></ol><p>技巧二：我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。</p><h2 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h2><p>git tag 在某种程度上 (因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1 C1</span><br></pre></td></tr></table></figure><h2 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h2><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 的语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p><code>git clone</code> 后，在我们的本地仓库多了一个名为 <code>o/master</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>为什么有 <code>o/</code>？</strong></p><p>远程分支有一个命名规范 —— 它们的格式是:</p><ul><li><code>&lt;remote name&gt;/&lt;branch name&gt;</code></li></ul><p>因此，如果你看到一个名为 <code>o/master</code> 的分支，那么这个分支就叫 <code>master</code>，远程仓库的名称就是 <code>o</code>。</p><p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，并不是 <code>o</code>。这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了。不过 <code>origin</code> 对于我们的 UI 来说太长了，因此不得不使用简写 <code>o</code> ，但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 <code>origin</code>!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout o&#x2F;master</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>Git 变成了分离 HEAD 状态，当添加新的提交时 <code>o/master</code> 也不会更新。这是因为 <code>o/master</code> 只有在远程仓库中相应的分支更新了以后才会更新。</p><h2 id="Git-Fetch"><a href="#Git-Fetch" class="headerlink" title="Git Fetch"></a>Git Fetch</h2><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/master</code>)</li></ul><p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>master</code> 分支，也不会修改你磁盘上的文件</p><h2 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h2><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/master</code></li><li><code>git rebase o/master</code></li><li><code>git merge o/master</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。<code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><h2 id="Git-Push"><a href="#Git-Push" class="headerlink" title="Git Push"></a>Git Push</h2><p>远程仓库接收了 <code>C2</code>，远程仓库中的 <code>master</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o/master) 也同样被更新了。所有的分支都同步了！</p><h2 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h2><p>如果你是在一个大的合作团队中工作, 很可能是master被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地master, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! [远程服务器拒绝] master -&gt; master (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure><p>远程服务器拒绝直接推送(push)提交到master, 因为策略配置要求 pull requests 来提交更新.你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了master.现在你卡住并且无法推送你的更新.<strong>新建一个分支feature, 推送到远程服务器. 然后reset你的master分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题</strong>.</p><h2 id="合并特性分支"><a href="#合并特性分支" class="headerlink" title="合并特性分支"></a>合并特性分支</h2><p>在大型项目中开发人员通常会在（从 <code>master</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。</p><p>但是有些开发人员只在 master 上做 push、pull —— 这样的话 master 总是最新的，始终与远程分支 (o/master) 保持一致。</p><p>对于接下来这个工作流，我们集成了两个步骤：</p><ul><li>将特性分支集成到 <code>master</code> 上</li><li>推送并更新远程分支</li></ul><h2 id="远程跟踪分支"><a href="#远程跟踪分支" class="headerlink" title="远程跟踪分支"></a>远程跟踪分支</h2><p>在前几节课程中有件事儿挺神奇的，Git 好像知道 <code>master</code> 与 <code>o/master</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 master 和本地的 master 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p><ul><li>pull 操作时, 提交记录会被先下载到 o/master 上，之后再合并到本地的 master 分支。隐含的合并目标由这个关联确定的。</li><li>push 操作时, 我们把工作从 <code>master</code> 推到远程仓库中的 <code>master</code> 分支(同时会更新远程分支 <code>o/master</code>) 。这个推送的目的地也是由这种关联确定的！</li></ul><p><strong>远程跟踪</strong></p><p>直接了当地讲，<code>master</code> 和 <code>o/master</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>master</code> 被设定为跟踪 <code>o/master</code> —— 这意味着为 <strong><code>master</code> 分支指定了推送的目的地以及拉取后合并的目标。</strong></p><p>你可能想知道 <code>master</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p><p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/master</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>master</code>。</p><p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p><p>这也解释了为什么会在克隆的时候会看到下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local branch &quot;master&quot; set to track remote branch &quot;o&#x2F;master&quot;</span><br></pre></td></tr></table></figure><p><strong>我能自己指定这个属性吗？</strong></p><p>当然可以啦！你可以让任意分支跟踪 <code>o/master</code>, 然后该分支会像 <code>master</code> 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 <code>totallyNotMaster</code> 上执行 <code>git push</code>，将工作推送到远程仓库的 <code>master</code> 分支上。</p><p>有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b totallyNotMaster o&#x2F;master</span><br></pre></td></tr></table></figure><p>就可以创建一个名为 <code>totallyNotMaster</code> 的分支，它跟踪远程分支 <code>o/master</code>。</p><p><strong>第二种方法</strong></p><p>另一种设置远程追踪分支的方法就是使用：<code>git branch -u</code> 命令，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o&#x2F;master foo</span><br></pre></td></tr></table></figure><p>这样 <code>foo</code> 就会跟踪 <code>o/master</code> 了。如果当前就在 foo 分支上, 还可以省略 foo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u o&#x2F;master</span><br></pre></td></tr></table></figure><h2 id="Git-Push-的参数"><a href="#Git-Push-的参数" class="headerlink" title="Git Push 的参数"></a>Git Push 的参数</h2><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;place&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;place&gt;</code> 参数是什么意思呢？我们稍后会深入其中的细节, 先看看例子, 这个命令是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>把这个命令翻译过来就是：</p><p><em>切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p><p>我们通过“place”参数来告诉 Git 提交记录来自于 master, 要推送到远程仓库中的 master。它实际就是要同步的两个仓库的位置。需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</p><p><strong><code>&lt;place&gt;</code>参数详解</strong>：</p><p>还记得之前课程说的吧，当为 git push 指定 place 参数为 <code>master</code> 时，我们同时指定了提交记录的来源和去向。</p><p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p><p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;source&gt;:&lt;destination&gt;</span><br></pre></td></tr></table></figure><p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了</p><h2 id="Git-fetch-的参数"><a href="#Git-fetch-的参数" class="headerlink" title="Git fetch 的参数"></a>Git fetch 的参数</h2><p><code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p><p>如果你像如下命令这样为 git fetch 设置 的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin foo</span><br></pre></td></tr></table></figure><p>Git 会到远程仓库的 <code>foo</code> 分支上，然后获取所有本地不存在的提交，放到本地的 <code>o/foo</code> 上。</p><p>为何 Git 会将新提交放到 <code>o/foo</code> 而不是放到我本地的 foo 分支呢？之前不是说这样的 参数就是同时应用于本地和远程的位置吗？好吧, 本例中 Git 做了一些特殊处理，因为你可能在 foo 分支上的工作还未完成，你也不想弄乱它。还记得在 <code>git fetch</code>课程里我们讲到的吗 —— 它不会更新你的本地的非远程分支, 只是下载提交记录（这样, 你就可以对远程分支进行检查或者合并了）。</p><p>如果你觉得直接更新本地分支很爽，那你就用冒号分隔的 refspec 吧。不过，你不能在当前检出的分支上干这个事，但是其它分支是可以的。这里有一点是需要注意的 —— <code>source</code> 现在指的是远程仓库中的位置，而 <code>&lt;destination&gt;</code> 才是要放置提交的本地仓库的位置。它与 git push 刚好相反，这是可以讲的通的，因为我们在往相反的方向传送数据。理论上虽然行的通，但开发人员很少这么做。我在这里介绍它主要是为了从概念上说明 <code>fetch</code> 和 <code>push</code> 的相似性，只是方向相反罢了。</p><h2 id="古怪的-lt-source-gt"><a href="#古怪的-lt-source-gt" class="headerlink" title="古怪的 &lt;source&gt;"></a>古怪的 <code>&lt;source&gt;</code></h2><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p><ul><li><code>git push origin :side</code></li><li><code>git fetch origin :bugFix</code></li></ul><p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p><p>如果 fetch 空 到本地，会在本地创建一个新分支。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>……</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
